"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/services/bitnob.service.ts":
/*!****************************************!*\
  !*** ./src/services/bitnob.service.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BitnobService: () => (/* binding */ BitnobService),\n/* harmony export */   bitnobService: () => (/* binding */ bitnobService),\n/* harmony export */   createBitnobService: () => (/* binding */ createBitnobService)\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Bitnob Service - Blockchain integration for SACCO platform\n * Handles Bitcoin Lightning Network payments, wallet operations, and KYC\n */ class BitnobService {\n    async makeRequest(endpoint) {\n        let method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'GET', data = arguments.length > 2 ? arguments[2] : void 0;\n        try {\n            // Create timeout controller\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 10000); // 10 second timeout\n            const response = await fetch(\"\".concat(this.baseURL).concat(endpoint), {\n                method,\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(this.config.apiKey),\n                    'Accept': 'application/json'\n                },\n                body: data ? JSON.stringify(data) : undefined,\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(\"Bitnob API Error: \".concat(response.status, \" - \").concat(errorData.message || response.statusText));\n            }\n            return await response.json();\n        } catch (error) {\n            console.error('Bitnob Service Error:', error);\n            // Handle specific network errors\n            if (error instanceof Error) {\n                if (error.message.includes('getaddrinfo ENOTFOUND') || error.message.includes('fetch failed')) {\n                    throw new Error('Bitnob service is currently unavailable. Please try again later.');\n                }\n                if (error.name === 'AbortError') {\n                    throw new Error('Bitnob service request timed out. Please try again.');\n                }\n            }\n            throw error;\n        }\n    }\n    // Check if Bitnob service is available\n    async isServiceAvailable() {\n        try {\n            // Check if API key is configured\n            if (!this.config.apiKey) {\n                console.warn('Bitnob API key not configured');\n                return false;\n            }\n            // Test with health endpoint\n            const response = await this.makeRequest('/health');\n            return response && response.status === 'ok';\n        } catch (error) {\n            console.error('Bitnob service availability check failed:', error);\n            return false;\n        }\n    }\n    // Test available endpoints\n    async testEndpoints() {\n        const endpoints = [\n            '/health',\n            '/ping',\n            '/wallets',\n            '/lightning/invoice',\n            '/lightning/send',\n            '/bitcoin/send',\n            '/rates'\n        ];\n        const results = {};\n        for (const endpoint of endpoints){\n            try {\n                const response = await fetch(\"\".concat(this.baseURL).concat(endpoint), {\n                    method: 'GET',\n                    headers: {\n                        'Authorization': \"Bearer \".concat(this.config.apiKey),\n                        'Content-Type': 'application/json'\n                    }\n                });\n                results[endpoint] = response.status !== 404;\n            } catch (error) {\n                results[endpoint] = false;\n            }\n        }\n        return results;\n    }\n    // Authentication and User Management\n    async createWallet(userData) {\n        try {\n            // First check if service is available\n            const isAvailable = await this.isServiceAvailable();\n            if (!isAvailable) {\n                throw new Error('Bitnob service is currently unavailable');\n            }\n            const response = await this.makeRequest('/wallets/create', 'POST', {\n                phoneNumber: userData.phoneNumber,\n                email: userData.email,\n                firstName: userData.firstName,\n                lastName: userData.lastName,\n                dateOfBirth: userData.dateOfBirth,\n                address: userData.address\n            });\n            return response.data;\n        } catch (error) {\n            console.error('Bitnob wallet creation error:', error);\n            throw new Error(\"Wallet creation failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getWalletDetails(walletId) {\n        try {\n            const response = await this.makeRequest(\"/wallets/\".concat(walletId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get wallet details: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getWalletBalance(walletId) {\n        try {\n            const response = await this.makeRequest(\"/wallets/\".concat(walletId, \"/balance\"));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Balance inquiry failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Lightning Network Operations\n    async sendLightningPayment(paymentData) {\n        try {\n            // Check if service is available first\n            const isAvailable = await this.isServiceAvailable();\n            if (!isAvailable) {\n                throw new Error('Bitnob service is currently unavailable. Please try again later.');\n            }\n            const response = await this.makeRequest('/lightning/send', 'POST', {\n                amount: paymentData.amount,\n                reference: paymentData.reference,\n                narration: paymentData.narration || 'SACCO Platform Payment'\n            });\n            return response.data;\n        } catch (error) {\n            console.error('Lightning payment error:', error);\n            if (error instanceof Error && error.message.includes('404')) {\n                throw new Error('Lightning payment service is temporarily unavailable. The API endpoint may have changed. Please contact support.');\n            }\n            throw new Error(\"Lightning payment failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async createLightningInvoice(invoiceData) {\n        try {\n            const response = await this.makeRequest('/lightning/invoice', 'POST', {\n                amount: invoiceData.amount,\n                currency: invoiceData.currency,\n                reference: invoiceData.reference,\n                memo: invoiceData.memo || 'SACCO Platform Payment',\n                expiresIn: invoiceData.expiresIn || 3600\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Invoice creation failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async payLightningInvoice(invoice, walletId) {\n        try {\n            const response = await this.makeRequest('/lightning/pay', 'POST', {\n                invoice,\n                walletId\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Invoice payment failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Bitcoin On-Chain Operations\n    async sendBitcoin(paymentData) {\n        try {\n            const response = await this.makeRequest('/bitcoin/send', 'POST', {\n                amount: paymentData.amount,\n                address: paymentData.address,\n                reference: paymentData.reference,\n                narration: paymentData.narration || 'SACCO Platform Payment'\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Bitcoin transaction failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async generateBitcoinAddress(walletId) {\n        try {\n            const response = await this.makeRequest(\"/bitcoin/address/\".concat(walletId), 'POST');\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Address generation failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // KYC Operations\n    async submitKYC(kycData) {\n        try {\n            // Note: File uploads would need FormData instead of JSON\n            const formData = new FormData();\n            Object.entries(kycData).forEach((param)=>{\n                let [key, value] = param;\n                if (value instanceof File) {\n                    formData.append(key, value);\n                } else if (value) {\n                    formData.append(key, value.toString());\n                }\n            });\n            const response = await fetch(\"\".concat(this.baseURL, \"/kyc/submit\"), {\n                method: 'POST',\n                headers: {\n                    'Authorization': \"Bearer \".concat(this.config.apiKey)\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(\"KYC submission failed: \".concat(errorData.message || response.statusText));\n            }\n            const result = await response.json();\n            return result.data;\n        } catch (error) {\n            throw new Error(\"KYC submission failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getKYCStatus(userId) {\n        try {\n            const response = await this.makeRequest(\"/kyc/status/\".concat(userId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"KYC status check failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Currency Conversion\n    async convertBTCToFiat(conversionData) {\n        try {\n            const response = await this.makeRequest('/convert', 'POST', {\n                amount: conversionData.amount,\n                fromCurrency: conversionData.fromCurrency,\n                toCurrency: conversionData.toCurrency,\n                reference: conversionData.reference\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Conversion failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getExchangeRates() {\n        let baseCurrency = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'BTC';\n        try {\n            const response = await this.makeRequest(\"/rates?base=\".concat(baseCurrency));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get exchange rates: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Transaction History\n    async getTransactionHistory(walletId) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50, offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        try {\n            const response = await this.makeRequest(\"/transactions?walletId=\".concat(walletId, \"&limit=\").concat(limit, \"&offset=\").concat(offset));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get transaction history: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getTransactionDetails(transactionId) {\n        try {\n            const response = await this.makeRequest(\"/transactions/\".concat(transactionId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get transaction details: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Webhook verification (for backend use)\n    verifyWebhookSignature(payload, signature, secret) {\n        // Implementation would depend on Bitnob's webhook signature method\n        // This is a placeholder for the actual verification logic\n        try {\n            const crypto = __webpack_require__(/*! crypto */ \"(app-pages-browser)/./node_modules/next/dist/compiled/crypto-browserify/index.js\");\n            const expectedSignature = crypto.createHmac('sha256', secret).update(payload).digest('hex');\n            return crypto.timingSafeEqual(Buffer.from(signature, 'hex'), Buffer.from(expectedSignature, 'hex'));\n        } catch (error) {\n            console.error('Webhook signature verification failed:', error);\n            return false;\n        }\n    }\n    // Health check\n    async healthCheck() {\n        try {\n            const response = await this.makeRequest('/health');\n            return response;\n        } catch (error) {\n            throw new Error(\"Health check failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    constructor(config){\n        this.config = config;\n        this.baseURL = config.baseURL || (config.environment === 'production' ? 'https://api.bitnob.com' : 'https://sandboxapi.bitnob.com');\n    }\n}\n// Singleton instance for frontend use\nlet bitnobServiceInstance = null;\nfunction createBitnobService(config) {\n    if (!bitnobServiceInstance || config) {\n        // Use new environment variable names\n        const clientId = process.env.BITNOB_CLIENT_ID || '';\n        const secretKey = process.env.BITNOB_SECRET_KEY || '';\n        const baseURL = process.env.BITNOB_BASE_URL || '';\n        // Use secret key as the API key for authentication\n        const apiKey = secretKey;\n        const serviceConfig = config || {\n            apiKey,\n            environment: baseURL.includes('sandbox') ? 'sandbox' : 'production',\n            baseURL: baseURL.replace('/api/v1', '')\n        };\n        // Warn if API key is missing\n        if (!apiKey) {\n            console.warn('Bitnob API key not configured. Bitcoin wallet features will be disabled.');\n        }\n        bitnobServiceInstance = new BitnobService(serviceConfig);\n    }\n    return bitnobServiceInstance;\n}\n// Default export for convenience\nconst bitnobService = createBitnobService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9iaXRub2Iuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Q0FHQyxHQXVETSxNQUFNQTtJQVlYLE1BQWNDLFlBQVlDLFFBQWdCLEVBQXNDO1lBQXBDQyxTQUFBQSxpRUFBaUIsT0FBT0M7UUFDbEUsSUFBSTtZQUNGLDRCQUE0QjtZQUM1QixNQUFNQyxhQUFhLElBQUlDO1lBQ3ZCLE1BQU1DLFlBQVlDLFdBQVcsSUFBTUgsV0FBV0ksS0FBSyxJQUFJLFFBQVEsb0JBQW9CO1lBRW5GLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFrQlQsT0FBZixJQUFJLENBQUNVLE9BQU8sRUFBWSxPQUFUVixXQUFZO2dCQUN6REM7Z0JBQ0FVLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixpQkFBaUIsVUFBNkIsT0FBbkIsSUFBSSxDQUFDQyxNQUFNLENBQUNDLE1BQU07b0JBQzdDLFVBQVU7Z0JBQ1o7Z0JBQ0FDLE1BQU1aLE9BQU9hLEtBQUtDLFNBQVMsQ0FBQ2QsUUFBUWU7Z0JBQ3BDQyxRQUFRZixXQUFXZSxNQUFNO1lBQzNCO1lBRUFDLGFBQWFkO1lBRWIsSUFBSSxDQUFDRyxTQUFTWSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTWIsU0FBU2MsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlDLE1BQU0scUJBQTBDSCxPQUFyQmIsU0FBU2lCLE1BQU0sRUFBQyxPQUE4QyxPQUF6Q0osVUFBVUssT0FBTyxJQUFJbEIsU0FBU21CLFVBQVU7WUFDcEc7WUFFQSxPQUFPLE1BQU1uQixTQUFTYyxJQUFJO1FBQzVCLEVBQUUsT0FBT00sT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMseUJBQXlCQTtZQUV2QyxpQ0FBaUM7WUFDakMsSUFBSUEsaUJBQWlCSixPQUFPO2dCQUMxQixJQUFJSSxNQUFNRixPQUFPLENBQUNJLFFBQVEsQ0FBQyw0QkFBNEJG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QixDQUFFO1FBQ2hDLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0YsT0FBTyxHQUFHRSxPQUFPRixPQUFPLElBQzFCRSxDQUFBQSxPQUFPMkYsV0FBVyxLQUFLLGVBQ3BCLDJCQUNBLCtCQUE4QjtJQUN0QztBQXdVRjtBQUVBLHNDQUFzQztBQUN0QyxJQUFJQyx3QkFBOEM7QUFFM0MsU0FBU0Msb0JBQW9CN0YsTUFBcUI7SUFDdkQsSUFBSSxDQUFDNEYseUJBQXlCNUYsUUFBUTtRQUNwQyxxQ0FBcUM7UUFDckMsTUFBTThGLFdBQVdDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsZ0JBQWdCLElBQUk7UUFDakQsTUFBTUMsWUFBWUgsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRyxpQkFBaUIsSUFBSTtRQUNuRCxNQUFNckcsVUFBVWlHLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0ksZUFBZSxJQUFJO1FBRS9DLG1EQUFtRDtRQUNuRCxNQUFNbkcsU0FBU2lHO1FBRWYsTUFBTUcsZ0JBQWdCckcsVUFBVTtZQUM5QkM7WUFDQTBGLGFBQWE3RixRQUFRb0IsUUFBUSxDQUFDLGFBQWEsWUFBWTtZQUN2RHBCLFNBQVNBLFFBQVF3RyxPQUFPLENBQUMsV0FBVztRQUN0QztRQUVBLDZCQUE2QjtRQUM3QixJQUFJLENBQUNyRyxRQUFRO1lBQ1hnQixRQUFRSSxJQUFJLENBQUM7UUFDZjtRQUVBdUUsd0JBQXdCLElBQUkxRyxjQUFjbUg7SUFDNUM7SUFFQSxPQUFPVDtBQUNUO0FBRUEsaUNBQWlDO0FBQzFCLE1BQU1XLGdCQUFnQlYsc0JBQXNCIiwic291cmNlcyI6WyIvaG9tZS9lcnJvcjUxL2JpdG5vYi9wcm9qZWN0L3ZpbGxhZ2Utc2FjY28vc3JjL3NlcnZpY2VzL2JpdG5vYi5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQml0bm9iIFNlcnZpY2UgLSBCbG9ja2NoYWluIGludGVncmF0aW9uIGZvciBTQUNDTyBwbGF0Zm9ybVxuICogSGFuZGxlcyBCaXRjb2luIExpZ2h0bmluZyBOZXR3b3JrIHBheW1lbnRzLCB3YWxsZXQgb3BlcmF0aW9ucywgYW5kIEtZQ1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgQml0bm9iQ29uZmlnIHtcbiAgYXBpS2V5OiBzdHJpbmc7XG4gIGVudmlyb25tZW50OiAnc2FuZGJveCcgfCAncHJvZHVjdGlvbic7XG4gIGJhc2VVUkw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0RGF0YSB7XG4gIHBob25lTnVtYmVyOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGZpcnN0TmFtZTogc3RyaW5nO1xuICBsYXN0TmFtZTogc3RyaW5nO1xuICBkYXRlT2ZCaXJ0aD86IHN0cmluZztcbiAgYWRkcmVzcz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXltZW50RGF0YSB7XG4gIGFtb3VudDogbnVtYmVyO1xuICBjdXJyZW5jeTogc3RyaW5nO1xuICByZWNpcGllbnRJZD86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG4gIGVtYWlsPzogc3RyaW5nO1xuICByZWZlcmVuY2U6IHN0cmluZztcbiAgbmFycmF0aW9uPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpZ2h0bmluZ0ludm9pY2VEYXRhIHtcbiAgYW1vdW50OiBudW1iZXI7XG4gIGN1cnJlbmN5OiBzdHJpbmc7XG4gIHJlZmVyZW5jZTogc3RyaW5nO1xuICBtZW1vPzogc3RyaW5nO1xuICBleHBpcmVzSW4/OiBudW1iZXI7IC8vIHNlY29uZHNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBLWUNEYXRhIHtcbiAgZmlyc3ROYW1lOiBzdHJpbmc7XG4gIGxhc3ROYW1lOiBzdHJpbmc7XG4gIGRhdGVPZkJpcnRoOiBzdHJpbmc7XG4gIHBob25lTnVtYmVyOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgaWRUeXBlOiAnbmluJyB8ICdwYXNzcG9ydCcgfCAnZHJpdmVyc19saWNlbnNlJztcbiAgaWROdW1iZXI6IHN0cmluZztcbiAgaWREb2N1bWVudD86IEZpbGU7XG4gIHByb29mT2ZBZGRyZXNzPzogRmlsZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzaW9uRGF0YSB7XG4gIGFtb3VudDogbnVtYmVyO1xuICBmcm9tQ3VycmVuY3k6IHN0cmluZztcbiAgdG9DdXJyZW5jeTogc3RyaW5nO1xuICByZWZlcmVuY2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEJpdG5vYlNlcnZpY2Uge1xuICBwcml2YXRlIGNvbmZpZzogQml0bm9iQ29uZmlnO1xuICBwcml2YXRlIGJhc2VVUkw6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEJpdG5vYkNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuYmFzZVVSTCA9IGNvbmZpZy5iYXNlVVJMIHx8IFxuICAgICAgKGNvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ3Byb2R1Y3Rpb24nIFxuICAgICAgICA/ICdodHRwczovL2FwaS5iaXRub2IuY29tJyBcbiAgICAgICAgOiAnaHR0cHM6Ly9zYW5kYm94YXBpLmJpdG5vYi5jb20nKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbWFrZVJlcXVlc3QoZW5kcG9pbnQ6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcgPSAnR0VUJywgZGF0YT86IGFueSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgdGltZW91dCBjb250cm9sbGVyXG4gICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIDEwMDAwKTsgLy8gMTAgc2Vjb25kIHRpbWVvdXRcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9JHtlbmRwb2ludH1gLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy5jb25maWcuYXBpS2V5fWAsXG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogZGF0YSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogdW5kZWZpbmVkLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgfSk7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRub2IgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gLSAke2Vycm9yRGF0YS5tZXNzYWdlIHx8IHJlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0JpdG5vYiBTZXJ2aWNlIEVycm9yOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIG5ldHdvcmsgZXJyb3JzXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZ2V0YWRkcmluZm8gRU5PVEZPVU5EJykgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZmV0Y2ggZmFpbGVkJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdG5vYiBzZXJ2aWNlIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZS4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaXRub2Igc2VydmljZSByZXF1ZXN0IHRpbWVkIG91dC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiBCaXRub2Igc2VydmljZSBpcyBhdmFpbGFibGVcbiAgYXN5bmMgaXNTZXJ2aWNlQXZhaWxhYmxlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiBBUEkga2V5IGlzIGNvbmZpZ3VyZWRcbiAgICAgIGlmICghdGhpcy5jb25maWcuYXBpS2V5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQml0bm9iIEFQSSBrZXkgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBUZXN0IHdpdGggaGVhbHRoIGVuZHBvaW50XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy9oZWFsdGgnKTtcbiAgICAgIHJldHVybiByZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXMgPT09ICdvayc7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0JpdG5vYiBzZXJ2aWNlIGF2YWlsYWJpbGl0eSBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRlc3QgYXZhaWxhYmxlIGVuZHBvaW50c1xuICBhc3luYyB0ZXN0RW5kcG9pbnRzKCk6IFByb21pc2U8eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0+IHtcbiAgICBjb25zdCBlbmRwb2ludHMgPSBbXG4gICAgICAnL2hlYWx0aCcsXG4gICAgICAnL3BpbmcnLCBcbiAgICAgICcvd2FsbGV0cycsXG4gICAgICAnL2xpZ2h0bmluZy9pbnZvaWNlJyxcbiAgICAgICcvbGlnaHRuaW5nL3NlbmQnLFxuICAgICAgJy9iaXRjb2luL3NlbmQnLFxuICAgICAgJy9yYXRlcydcbiAgICBdO1xuXG4gICAgY29uc3QgcmVzdWx0czogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fTtcblxuICAgIGZvciAoY29uc3QgZW5kcG9pbnQgb2YgZW5kcG9pbnRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0ke2VuZHBvaW50fWAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuY29uZmlnLmFwaUtleX1gLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0c1tlbmRwb2ludF0gPSByZXNwb25zZS5zdGF0dXMgIT09IDQwNDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlc3VsdHNbZW5kcG9pbnRdID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvLyBBdXRoZW50aWNhdGlvbiBhbmQgVXNlciBNYW5hZ2VtZW50XG4gIGFzeW5jIGNyZWF0ZVdhbGxldCh1c2VyRGF0YTogV2FsbGV0RGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiBzZXJ2aWNlIGlzIGF2YWlsYWJsZVxuICAgICAgY29uc3QgaXNBdmFpbGFibGUgPSBhd2FpdCB0aGlzLmlzU2VydmljZUF2YWlsYWJsZSgpO1xuICAgICAgaWYgKCFpc0F2YWlsYWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdG5vYiBzZXJ2aWNlIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy93YWxsZXRzL2NyZWF0ZScsICdQT1NUJywge1xuICAgICAgICBwaG9uZU51bWJlcjogdXNlckRhdGEucGhvbmVOdW1iZXIsXG4gICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcbiAgICAgICAgZmlyc3ROYW1lOiB1c2VyRGF0YS5maXJzdE5hbWUsXG4gICAgICAgIGxhc3ROYW1lOiB1c2VyRGF0YS5sYXN0TmFtZSxcbiAgICAgICAgZGF0ZU9mQmlydGg6IHVzZXJEYXRhLmRhdGVPZkJpcnRoLFxuICAgICAgICBhZGRyZXNzOiB1c2VyRGF0YS5hZGRyZXNzLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQml0bm9iIHdhbGxldCBjcmVhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdhbGxldCBjcmVhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0V2FsbGV0RGV0YWlscyh3YWxsZXRJZDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgL3dhbGxldHMvJHt3YWxsZXRJZH1gKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgd2FsbGV0IGRldGFpbHM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0V2FsbGV0QmFsYW5jZSh3YWxsZXRJZDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgL3dhbGxldHMvJHt3YWxsZXRJZH0vYmFsYW5jZWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFsYW5jZSBpbnF1aXJ5IGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICAvLyBMaWdodG5pbmcgTmV0d29yayBPcGVyYXRpb25zXG4gIGFzeW5jIHNlbmRMaWdodG5pbmdQYXltZW50KHBheW1lbnREYXRhOiBQYXltZW50RGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiBzZXJ2aWNlIGlzIGF2YWlsYWJsZSBmaXJzdFxuICAgICAgY29uc3QgaXNBdmFpbGFibGUgPSBhd2FpdCB0aGlzLmlzU2VydmljZUF2YWlsYWJsZSgpO1xuICAgICAgaWYgKCFpc0F2YWlsYWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdG5vYiBzZXJ2aWNlIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZS4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCcvbGlnaHRuaW5nL3NlbmQnLCAnUE9TVCcsIHtcbiAgICAgICAgYW1vdW50OiBwYXltZW50RGF0YS5hbW91bnQsXG4gICAgICAgIHJlZmVyZW5jZTogcGF5bWVudERhdGEucmVmZXJlbmNlLFxuICAgICAgICBuYXJyYXRpb246IHBheW1lbnREYXRhLm5hcnJhdGlvbiB8fCAnU0FDQ08gUGxhdGZvcm0gUGF5bWVudCcsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMaWdodG5pbmcgcGF5bWVudCBlcnJvcjonLCBlcnJvcik7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCc0MDQnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpZ2h0bmluZyBwYXltZW50IHNlcnZpY2UgaXMgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUuIFRoZSBBUEkgZW5kcG9pbnQgbWF5IGhhdmUgY2hhbmdlZC4gUGxlYXNlIGNvbnRhY3Qgc3VwcG9ydC4nKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGlnaHRuaW5nIHBheW1lbnQgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUxpZ2h0bmluZ0ludm9pY2UoaW52b2ljZURhdGE6IExpZ2h0bmluZ0ludm9pY2VEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2xpZ2h0bmluZy9pbnZvaWNlJywgJ1BPU1QnLCB7XG4gICAgICAgIGFtb3VudDogaW52b2ljZURhdGEuYW1vdW50LFxuICAgICAgICBjdXJyZW5jeTogaW52b2ljZURhdGEuY3VycmVuY3ksXG4gICAgICAgIHJlZmVyZW5jZTogaW52b2ljZURhdGEucmVmZXJlbmNlLFxuICAgICAgICBtZW1vOiBpbnZvaWNlRGF0YS5tZW1vIHx8ICdTQUNDTyBQbGF0Zm9ybSBQYXltZW50JyxcbiAgICAgICAgZXhwaXJlc0luOiBpbnZvaWNlRGF0YS5leHBpcmVzSW4gfHwgMzYwMCwgLy8gMSBob3VyIGRlZmF1bHRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52b2ljZSBjcmVhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcGF5TGlnaHRuaW5nSW52b2ljZShpbnZvaWNlOiBzdHJpbmcsIHdhbGxldElkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCcvbGlnaHRuaW5nL3BheScsICdQT1NUJywge1xuICAgICAgICBpbnZvaWNlLFxuICAgICAgICB3YWxsZXRJZCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52b2ljZSBwYXltZW50IGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICAvLyBCaXRjb2luIE9uLUNoYWluIE9wZXJhdGlvbnNcbiAgYXN5bmMgc2VuZEJpdGNvaW4ocGF5bWVudERhdGE6IFBheW1lbnREYXRhICYgeyBhZGRyZXNzOiBzdHJpbmcgfSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy9iaXRjb2luL3NlbmQnLCAnUE9TVCcsIHtcbiAgICAgICAgYW1vdW50OiBwYXltZW50RGF0YS5hbW91bnQsXG4gICAgICAgIGFkZHJlc3M6IHBheW1lbnREYXRhLmFkZHJlc3MsXG4gICAgICAgIHJlZmVyZW5jZTogcGF5bWVudERhdGEucmVmZXJlbmNlLFxuICAgICAgICBuYXJyYXRpb246IHBheW1lbnREYXRhLm5hcnJhdGlvbiB8fCAnU0FDQ08gUGxhdGZvcm0gUGF5bWVudCcsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdGNvaW4gdHJhbnNhY3Rpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlQml0Y29pbkFkZHJlc3Mod2FsbGV0SWQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYC9iaXRjb2luL2FkZHJlc3MvJHt3YWxsZXRJZH1gLCAnUE9TVCcpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyBnZW5lcmF0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICAvLyBLWUMgT3BlcmF0aW9uc1xuICBhc3luYyBzdWJtaXRLWUMoa3ljRGF0YTogS1lDRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBOb3RlOiBGaWxlIHVwbG9hZHMgd291bGQgbmVlZCBGb3JtRGF0YSBpbnN0ZWFkIG9mIEpTT05cbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBPYmplY3QuZW50cmllcyhreWNEYXRhKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2t5Yy9zdWJtaXRgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy5jb25maWcuYXBpS2V5fWAsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtZQyBzdWJtaXNzaW9uIGZhaWxlZDogJHtlcnJvckRhdGEubWVzc2FnZSB8fCByZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS1lDIHN1Ym1pc3Npb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldEtZQ1N0YXR1cyh1c2VySWQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYC9reWMvc3RhdHVzLyR7dXNlcklkfWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS1lDIHN0YXR1cyBjaGVjayBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3VycmVuY3kgQ29udmVyc2lvblxuICBhc3luYyBjb252ZXJ0QlRDVG9GaWF0KGNvbnZlcnNpb25EYXRhOiBDb252ZXJzaW9uRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy9jb252ZXJ0JywgJ1BPU1QnLCB7XG4gICAgICAgIGFtb3VudDogY29udmVyc2lvbkRhdGEuYW1vdW50LFxuICAgICAgICBmcm9tQ3VycmVuY3k6IGNvbnZlcnNpb25EYXRhLmZyb21DdXJyZW5jeSxcbiAgICAgICAgdG9DdXJyZW5jeTogY29udmVyc2lvbkRhdGEudG9DdXJyZW5jeSxcbiAgICAgICAgcmVmZXJlbmNlOiBjb252ZXJzaW9uRGF0YS5yZWZlcmVuY2UsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnNpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldEV4Y2hhbmdlUmF0ZXMoYmFzZUN1cnJlbmN5OiBzdHJpbmcgPSAnQlRDJykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYC9yYXRlcz9iYXNlPSR7YmFzZUN1cnJlbmN5fWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBleGNoYW5nZSByYXRlczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICAvLyBUcmFuc2FjdGlvbiBIaXN0b3J5XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uSGlzdG9yeSh3YWxsZXRJZDogc3RyaW5nLCBsaW1pdDogbnVtYmVyID0gNTAsIG9mZnNldDogbnVtYmVyID0gMCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoXG4gICAgICAgIGAvdHJhbnNhY3Rpb25zP3dhbGxldElkPSR7d2FsbGV0SWR9JmxpbWl0PSR7bGltaXR9Jm9mZnNldD0ke29mZnNldH1gXG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbiBoaXN0b3J5OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uRGV0YWlscyh0cmFuc2FjdGlvbklkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAvdHJhbnNhY3Rpb25zLyR7dHJhbnNhY3Rpb25JZH1gKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24gZGV0YWlsczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICAvLyBXZWJob29rIHZlcmlmaWNhdGlvbiAoZm9yIGJhY2tlbmQgdXNlKVxuICB2ZXJpZnlXZWJob29rU2lnbmF0dXJlKHBheWxvYWQ6IHN0cmluZywgc2lnbmF0dXJlOiBzdHJpbmcsIHNlY3JldDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gSW1wbGVtZW50YXRpb24gd291bGQgZGVwZW5kIG9uIEJpdG5vYidzIHdlYmhvb2sgc2lnbmF0dXJlIG1ldGhvZFxuICAgIC8vIFRoaXMgaXMgYSBwbGFjZWhvbGRlciBmb3IgdGhlIGFjdHVhbCB2ZXJpZmljYXRpb24gbG9naWNcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgICBjb25zdCBleHBlY3RlZFNpZ25hdHVyZSA9IGNyeXB0b1xuICAgICAgICAuY3JlYXRlSG1hYygnc2hhMjU2Jywgc2VjcmV0KVxuICAgICAgICAudXBkYXRlKHBheWxvYWQpXG4gICAgICAgIC5kaWdlc3QoJ2hleCcpO1xuICAgICAgXG4gICAgICByZXR1cm4gY3J5cHRvLnRpbWluZ1NhZmVFcXVhbChcbiAgICAgICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlLCAnaGV4JyksXG4gICAgICAgIEJ1ZmZlci5mcm9tKGV4cGVjdGVkU2lnbmF0dXJlLCAnaGV4JylcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dlYmhvb2sgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhlYWx0aCBjaGVja1xuICBhc3luYyBoZWFsdGhDaGVjaygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCcvaGVhbHRoJyk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSGVhbHRoIGNoZWNrIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gU2luZ2xldG9uIGluc3RhbmNlIGZvciBmcm9udGVuZCB1c2VcbmxldCBiaXRub2JTZXJ2aWNlSW5zdGFuY2U6IEJpdG5vYlNlcnZpY2UgfCBudWxsID0gbnVsbDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJpdG5vYlNlcnZpY2UoY29uZmlnPzogQml0bm9iQ29uZmlnKTogQml0bm9iU2VydmljZSB7XG4gIGlmICghYml0bm9iU2VydmljZUluc3RhbmNlIHx8IGNvbmZpZykge1xuICAgIC8vIFVzZSBuZXcgZW52aXJvbm1lbnQgdmFyaWFibGUgbmFtZXNcbiAgICBjb25zdCBjbGllbnRJZCA9IHByb2Nlc3MuZW52LkJJVE5PQl9DTElFTlRfSUQgfHwgJyc7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gcHJvY2Vzcy5lbnYuQklUTk9CX1NFQ1JFVF9LRVkgfHwgJyc7XG4gICAgY29uc3QgYmFzZVVSTCA9IHByb2Nlc3MuZW52LkJJVE5PQl9CQVNFX1VSTCB8fCAnJztcbiAgICBcbiAgICAvLyBVc2Ugc2VjcmV0IGtleSBhcyB0aGUgQVBJIGtleSBmb3IgYXV0aGVudGljYXRpb25cbiAgICBjb25zdCBhcGlLZXkgPSBzZWNyZXRLZXk7XG4gICAgXG4gICAgY29uc3Qgc2VydmljZUNvbmZpZyA9IGNvbmZpZyB8fCB7XG4gICAgICBhcGlLZXksXG4gICAgICBlbnZpcm9ubWVudDogYmFzZVVSTC5pbmNsdWRlcygnc2FuZGJveCcpID8gJ3NhbmRib3gnIDogJ3Byb2R1Y3Rpb24nLFxuICAgICAgYmFzZVVSTDogYmFzZVVSTC5yZXBsYWNlKCcvYXBpL3YxJywgJycpLCAvLyBSZW1vdmUgL2FwaS92MSBmcm9tIGJhc2UgVVJMIHNpbmNlIGVuZHBvaW50cyBkb24ndCB1c2UgaXRcbiAgICB9O1xuXG4gICAgLy8gV2FybiBpZiBBUEkga2V5IGlzIG1pc3NpbmdcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgY29uc29sZS53YXJuKCdCaXRub2IgQVBJIGtleSBub3QgY29uZmlndXJlZC4gQml0Y29pbiB3YWxsZXQgZmVhdHVyZXMgd2lsbCBiZSBkaXNhYmxlZC4nKTtcbiAgICB9XG5cbiAgICBiaXRub2JTZXJ2aWNlSW5zdGFuY2UgPSBuZXcgQml0bm9iU2VydmljZShzZXJ2aWNlQ29uZmlnKTtcbiAgfVxuXG4gIHJldHVybiBiaXRub2JTZXJ2aWNlSW5zdGFuY2U7XG59XG5cbi8vIERlZmF1bHQgZXhwb3J0IGZvciBjb252ZW5pZW5jZVxuZXhwb3J0IGNvbnN0IGJpdG5vYlNlcnZpY2UgPSBjcmVhdGVCaXRub2JTZXJ2aWNlKCk7XG4iXSwibmFtZXMiOlsiQml0bm9iU2VydmljZSIsIm1ha2VSZXF1ZXN0IiwiZW5kcG9pbnQiLCJtZXRob2QiLCJkYXRhIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJiYXNlVVJMIiwiaGVhZGVycyIsImNvbmZpZyIsImFwaUtleSIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidW5kZWZpbmVkIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJFcnJvciIsInN0YXR1cyIsIm1lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiZXJyb3IiLCJjb25zb2xlIiwiaW5jbHVkZXMiLCJuYW1lIiwiaXNTZXJ2aWNlQXZhaWxhYmxlIiwid2FybiIsInRlc3RFbmRwb2ludHMiLCJlbmRwb2ludHMiLCJyZXN1bHRzIiwiY3JlYXRlV2FsbGV0IiwidXNlckRhdGEiLCJpc0F2YWlsYWJsZSIsInBob25lTnVtYmVyIiwiZW1haWwiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImRhdGVPZkJpcnRoIiwiYWRkcmVzcyIsImdldFdhbGxldERldGFpbHMiLCJ3YWxsZXRJZCIsImdldFdhbGxldEJhbGFuY2UiLCJzZW5kTGlnaHRuaW5nUGF5bWVudCIsInBheW1lbnREYXRhIiwiYW1vdW50IiwicmVmZXJlbmNlIiwibmFycmF0aW9uIiwiY3JlYXRlTGlnaHRuaW5nSW52b2ljZSIsImludm9pY2VEYXRhIiwiY3VycmVuY3kiLCJtZW1vIiwiZXhwaXJlc0luIiwicGF5TGlnaHRuaW5nSW52b2ljZSIsImludm9pY2UiLCJzZW5kQml0Y29pbiIsImdlbmVyYXRlQml0Y29pbkFkZHJlc3MiLCJzdWJtaXRLWUMiLCJreWNEYXRhIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJGaWxlIiwiYXBwZW5kIiwidG9TdHJpbmciLCJyZXN1bHQiLCJnZXRLWUNTdGF0dXMiLCJ1c2VySWQiLCJjb252ZXJ0QlRDVG9GaWF0IiwiY29udmVyc2lvbkRhdGEiLCJmcm9tQ3VycmVuY3kiLCJ0b0N1cnJlbmN5IiwiZ2V0RXhjaGFuZ2VSYXRlcyIsImJhc2VDdXJyZW5jeSIsImdldFRyYW5zYWN0aW9uSGlzdG9yeSIsImxpbWl0Iiwib2Zmc2V0IiwiZ2V0VHJhbnNhY3Rpb25EZXRhaWxzIiwidHJhbnNhY3Rpb25JZCIsInZlcmlmeVdlYmhvb2tTaWduYXR1cmUiLCJwYXlsb2FkIiwic2lnbmF0dXJlIiwic2VjcmV0IiwiY3J5cHRvIiwicmVxdWlyZSIsImV4cGVjdGVkU2lnbmF0dXJlIiwiY3JlYXRlSG1hYyIsInVwZGF0ZSIsImRpZ2VzdCIsInRpbWluZ1NhZmVFcXVhbCIsIkJ1ZmZlciIsImZyb20iLCJoZWFsdGhDaGVjayIsImVudmlyb25tZW50IiwiYml0bm9iU2VydmljZUluc3RhbmNlIiwiY3JlYXRlQml0bm9iU2VydmljZSIsImNsaWVudElkIiwicHJvY2VzcyIsImVudiIsIkJJVE5PQl9DTElFTlRfSUQiLCJzZWNyZXRLZXkiLCJCSVROT0JfU0VDUkVUX0tFWSIsIkJJVE5PQl9CQVNFX1VSTCIsInNlcnZpY2VDb25maWciLCJyZXBsYWNlIiwiYml0bm9iU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/bitnob.service.ts\n"));

/***/ })

});