"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/services/bitnob.service.ts":
/*!****************************************!*\
  !*** ./src/services/bitnob.service.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BitnobService: () => (/* binding */ BitnobService),\n/* harmony export */   bitnobService: () => (/* binding */ bitnobService),\n/* harmony export */   createBitnobService: () => (/* binding */ createBitnobService)\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/**\n * Bitnob Service - Blockchain integration for SACCO platform\n * Handles Bitcoin Lightning Network payments, wallet operations, and KYC\n */ class BitnobService {\n    async makeRequest(endpoint) {\n        let method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'GET', data = arguments.length > 2 ? arguments[2] : void 0;\n        try {\n            // Create timeout controller\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 10000); // 10 second timeout\n            const response = await fetch(\"\".concat(this.baseURL).concat(endpoint), {\n                method,\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(this.config.apiKey),\n                    'Accept': 'application/json'\n                },\n                body: data ? JSON.stringify(data) : undefined,\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(\"Bitnob API Error: \".concat(response.status, \" - \").concat(errorData.message || response.statusText));\n            }\n            return await response.json();\n        } catch (error) {\n            console.error('Bitnob Service Error:', error);\n            // Handle specific network errors\n            if (error instanceof Error) {\n                if (error.message.includes('getaddrinfo ENOTFOUND') || error.message.includes('fetch failed')) {\n                    throw new Error('Bitnob service is currently unavailable. Please try again later.');\n                }\n                if (error.name === 'AbortError') {\n                    throw new Error('Bitnob service request timed out. Please try again.');\n                }\n            }\n            throw error;\n        }\n    }\n    // Check if Bitnob service is available\n    async isServiceAvailable() {\n        try {\n            // Check if API key is configured\n            if (!this.config.apiKey) {\n                console.warn('Bitnob API key not configured');\n                return false;\n            }\n            // Test with health endpoint\n            const response = await this.makeRequest('/health');\n            return response && response.status === 'ok';\n        } catch (error) {\n            console.error('Bitnob service availability check failed:', error);\n            return false;\n        }\n    }\n    // Test available endpoints\n    async testEndpoints() {\n        const endpoints = [\n            '/health',\n            '/ping',\n            '/wallets',\n            '/lightning/invoice',\n            '/lightning/send',\n            '/bitcoin/send',\n            '/rates'\n        ];\n        const results = {};\n        for (const endpoint of endpoints){\n            try {\n                const response = await fetch(\"\".concat(this.baseURL).concat(endpoint), {\n                    method: 'GET',\n                    headers: {\n                        'Authorization': \"Bearer \".concat(this.config.apiKey),\n                        'Content-Type': 'application/json'\n                    }\n                });\n                results[endpoint] = response.status !== 404;\n            } catch (error) {\n                results[endpoint] = false;\n            }\n        }\n        return results;\n    }\n    // Authentication and User Management\n    async createWallet(userData) {\n        try {\n            // First check if service is available\n            const isAvailable = await this.isServiceAvailable();\n            if (!isAvailable) {\n                throw new Error('Bitnob service is currently unavailable');\n            }\n            const response = await this.makeRequest('/wallets/create', 'POST', {\n                phoneNumber: userData.phoneNumber,\n                email: userData.email,\n                firstName: userData.firstName,\n                lastName: userData.lastName,\n                dateOfBirth: userData.dateOfBirth,\n                address: userData.address\n            });\n            return response.data;\n        } catch (error) {\n            console.error('Bitnob wallet creation error:', error);\n            throw new Error(\"Wallet creation failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getWalletDetails(walletId) {\n        try {\n            const response = await this.makeRequest(\"/wallets/\".concat(walletId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get wallet details: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getWalletBalance(walletId) {\n        try {\n            const response = await this.makeRequest(\"/wallets/\".concat(walletId, \"/balance\"));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Balance inquiry failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Lightning Network Operations\n    async sendLightningPayment(paymentData) {\n        try {\n            // Check if service is available first\n            const isAvailable = await this.isServiceAvailable();\n            if (!isAvailable) {\n                throw new Error('Bitnob service is currently unavailable. Please try again later.');\n            }\n            const response = await this.makeRequest('/lightning/send', 'POST', {\n                amount: paymentData.amount,\n                reference: paymentData.reference,\n                narration: paymentData.narration || 'SACCO Platform Payment'\n            });\n            return response.data;\n        } catch (error) {\n            console.error('Lightning payment error:', error);\n            if (error instanceof Error && error.message.includes('404')) {\n                throw new Error('Lightning payment service is temporarily unavailable. The API endpoint may have changed. Please contact support.');\n            }\n            throw new Error(\"Lightning payment failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async createLightningInvoice(invoiceData) {\n        try {\n            const response = await this.makeRequest('/lightning/invoice', 'POST', {\n                amount: invoiceData.amount,\n                currency: invoiceData.currency,\n                reference: invoiceData.reference,\n                memo: invoiceData.memo || 'SACCO Platform Payment',\n                expiresIn: invoiceData.expiresIn || 3600\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Invoice creation failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async payLightningInvoice(invoice, walletId) {\n        try {\n            const response = await this.makeRequest('/lightning/pay', 'POST', {\n                invoice,\n                walletId\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Invoice payment failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Bitcoin On-Chain Operations\n    async sendBitcoin(paymentData) {\n        try {\n            const response = await this.makeRequest('/bitcoin/send', 'POST', {\n                amount: paymentData.amount,\n                address: paymentData.address,\n                reference: paymentData.reference,\n                narration: paymentData.narration || 'SACCO Platform Payment'\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Bitcoin transaction failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async generateBitcoinAddress(walletId) {\n        try {\n            const response = await this.makeRequest(\"/bitcoin/address/\".concat(walletId), 'POST');\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Address generation failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // KYC Operations\n    async submitKYC(kycData) {\n        try {\n            // Note: File uploads would need FormData instead of JSON\n            const formData = new FormData();\n            Object.entries(kycData).forEach((param)=>{\n                let [key, value] = param;\n                if (value instanceof File) {\n                    formData.append(key, value);\n                } else if (value) {\n                    formData.append(key, value.toString());\n                }\n            });\n            const response = await fetch(\"\".concat(this.baseURL, \"/kyc/submit\"), {\n                method: 'POST',\n                headers: {\n                    'Authorization': \"Bearer \".concat(this.config.apiKey)\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(\"KYC submission failed: \".concat(errorData.message || response.statusText));\n            }\n            const result = await response.json();\n            return result.data;\n        } catch (error) {\n            throw new Error(\"KYC submission failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getKYCStatus(userId) {\n        try {\n            const response = await this.makeRequest(\"/kyc/status/\".concat(userId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"KYC status check failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Currency Conversion\n    async convertBTCToFiat(conversionData) {\n        try {\n            const response = await this.makeRequest('/convert', 'POST', {\n                amount: conversionData.amount,\n                fromCurrency: conversionData.fromCurrency,\n                toCurrency: conversionData.toCurrency,\n                reference: conversionData.reference\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Conversion failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getExchangeRates() {\n        let baseCurrency = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'BTC';\n        try {\n            const response = await this.makeRequest(\"/rates?base=\".concat(baseCurrency));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get exchange rates: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Transaction History\n    async getTransactionHistory(walletId) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50, offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        try {\n            const response = await this.makeRequest(\"/transactions?walletId=\".concat(walletId, \"&limit=\").concat(limit, \"&offset=\").concat(offset));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get transaction history: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getTransactionDetails(transactionId) {\n        try {\n            const response = await this.makeRequest(\"/transactions/\".concat(transactionId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get transaction details: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Webhook verification (for backend use)\n    verifyWebhookSignature(payload, signature, secret) {\n        // Implementation would depend on Bitnob's webhook signature method\n        // This is a placeholder for the actual verification logic\n        try {\n            const crypto = __webpack_require__(/*! crypto */ \"(app-pages-browser)/./node_modules/next/dist/compiled/crypto-browserify/index.js\");\n            const expectedSignature = crypto.createHmac('sha256', secret).update(payload).digest('hex');\n            return crypto.timingSafeEqual(Buffer.from(signature, 'hex'), Buffer.from(expectedSignature, 'hex'));\n        } catch (error) {\n            console.error('Webhook signature verification failed:', error);\n            return false;\n        }\n    }\n    // Health check\n    async healthCheck() {\n        try {\n            const response = await this.makeRequest('/health');\n            return response;\n        } catch (error) {\n            throw new Error(\"Health check failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    constructor(config){\n        this.config = config;\n        this.baseURL = config.baseURL || (config.environment === 'production' ? 'https://api.bitnob.com' : 'https://sandboxapi.bitnob.com');\n    }\n}\n// Singleton instance for frontend use\nlet bitnobServiceInstance = null;\nfunction createBitnobService(config) {\n    if (!bitnobServiceInstance || config) {\n        const apiKey = \"hsk.d550cb2465fe.d92cf979e734a2baae0470a48\" || 0;\n        const serviceConfig = config || {\n            apiKey,\n            environment: \"sandbox\" || 0,\n            baseURL: \"https://sandboxapi.bitnob.co\"\n        };\n        // Warn if API key is missing\n        if (!apiKey) {\n            console.warn('Bitnob API key not configured. Bitcoin wallet features will be disabled.');\n        }\n        bitnobServiceInstance = new BitnobService(serviceConfig);\n    }\n    return bitnobServiceInstance;\n}\n// Default export for convenience\nconst bitnobService = createBitnobService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9iaXRub2Iuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7OztDQUdDLEdBdURNLE1BQU1BO0lBWVgsTUFBY0MsWUFBWUMsUUFBZ0IsRUFBc0M7WUFBcENDLFNBQUFBLGlFQUFpQixPQUFPQztRQUNsRSxJQUFJO1lBQ0YsNEJBQTRCO1lBQzVCLE1BQU1DLGFBQWEsSUFBSUM7WUFDdkIsTUFBTUMsWUFBWUMsV0FBVyxJQUFNSCxXQUFXSSxLQUFLLElBQUksUUFBUSxvQkFBb0I7WUFFbkYsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQWtCVCxPQUFmLElBQUksQ0FBQ1UsT0FBTyxFQUFZLE9BQVRWLFdBQVk7Z0JBQ3pEQztnQkFDQVUsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLGlCQUFpQixVQUE2QixPQUFuQixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsTUFBTTtvQkFDN0MsVUFBVTtnQkFDWjtnQkFDQUMsTUFBTVosT0FBT2EsS0FBS0MsU0FBUyxDQUFDZCxRQUFRZTtnQkFDcENDLFFBQVFmLFdBQVdlLE1BQU07WUFDM0I7WUFFQUMsYUFBYWQ7WUFFYixJQUFJLENBQUNHLFNBQVNZLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNYixTQUFTYyxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSUMsTUFBTSxxQkFBMENILE9BQXJCYixTQUFTaUIsTUFBTSxFQUFDLE9BQThDLE9BQXpDSixVQUFVSyxPQUFPLElBQUlsQixTQUFTbUIsVUFBVTtZQUNwRztZQUVBLE9BQU8sTUFBTW5CLFNBQVNjLElBQUk7UUFDNUIsRUFBRSxPQUFPTSxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyx5QkFBeUJBO1lBRXZDLGlDQUFpQztZQUNqQyxJQUFJQSxpQkFBaUJKLE9BQU87Z0JBQzFCLElBQUlJLE1BQU1GLE9BQU8sQ0FBQ0ksUUFBUSxDQUFDLDRCQUE0QkYsTUFBTUYsT0FBTyxDQUFDSSxRQUFRLENBQUMsaUJBQWlCO29CQUM3RixNQUFNLElBQUlOLE1BQU07Z0JBQ2xCO2dCQUNBLElBQUlJLE1BQU1HLElBQUksS0FBSyxjQUFjO29CQUMvQixNQUFNLElBQUlQLE1BQU07Z0JBQ2xCO1lBQ0Y7WUFFQSxNQUFNSTtRQUNSO0lBQ0Y7SUFFQSx1Q0FBdUM7SUFDdkMsTUFBTUkscUJBQXVDO1FBQzNDLElBQUk7WUFDRixpQ0FBaUM7WUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQ0MsTUFBTSxFQUFFO2dCQUN2QmdCLFFBQVFJLElBQUksQ0FBQztnQkFDYixPQUFPO1lBQ1Q7WUFFQSw0QkFBNEI7WUFDNUIsTUFBTXpCLFdBQVcsTUFBTSxJQUFJLENBQUNULFdBQVcsQ0FBQztZQUN4QyxPQUFPUyxZQUFZQSxTQUFTaUIsTUFBTSxLQUFLO1FBQ3pDLEVBQUUsT0FBT0csT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsNkNBQTZDQTtZQUMzRCxPQUFPO1FBQ1Q7SUFDRjtJQUVBLDJCQUEyQjtJQUMzQixNQUFNTSxnQkFBcUQ7UUFDekQsTUFBTUMsWUFBWTtZQUNoQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtTQUNEO1FBRUQsTUFBTUMsVUFBc0MsQ0FBQztRQUU3QyxLQUFLLE1BQU1wQyxZQUFZbUMsVUFBVztZQUNoQyxJQUFJO2dCQUNGLE1BQU0zQixXQUFXLE1BQU1DLE1BQU0sR0FBa0JULE9BQWYsSUFBSSxDQUFDVSxPQUFPLEVBQVksT0FBVFYsV0FBWTtvQkFDekRDLFFBQVE7b0JBQ1JVLFNBQVM7d0JBQ1AsaUJBQWlCLFVBQTZCLE9BQW5CLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxNQUFNO3dCQUM3QyxnQkFBZ0I7b0JBQ2xCO2dCQUNGO2dCQUNBdUIsT0FBTyxDQUFDcEMsU0FBUyxHQUFHUSxTQUFTaUIsTUFBTSxLQUFLO1lBQzFDLEVBQUUsT0FBT0csT0FBTztnQkFDZFEsT0FBTyxDQUFDcEMsU0FBUyxHQUFHO1lBQ3RCO1FBQ0Y7UUFFQSxPQUFPb0M7SUFDVDtJQUVBLHFDQUFxQztJQUNyQyxNQUFNQyxhQUFhQyxRQUFvQixFQUFFO1FBQ3ZDLElBQUk7WUFDRixzQ0FBc0M7WUFDdEMsTUFBTUMsY0FBYyxNQUFNLElBQUksQ0FBQ1Asa0JBQWtCO1lBQ2pELElBQUksQ0FBQ08sYUFBYTtnQkFDaEIsTUFBTSxJQUFJZixNQUFNO1lBQ2xCO1lBRUEsTUFBTWhCLFdBQVcsTUFBTSxJQUFJLENBQUNULFdBQVcsQ0FBQyxtQkFBbUIsUUFBUTtnQkFDakV5QyxhQUFhRixTQUFTRSxXQUFXO2dCQUNqQ0MsT0FBT0gsU0FBU0csS0FBSztnQkFDckJDLFdBQVdKLFNBQVNJLFNBQVM7Z0JBQzdCQyxVQUFVTCxTQUFTSyxRQUFRO2dCQUMzQkMsYUFBYU4sU0FBU00sV0FBVztnQkFDakNDLFNBQVNQLFNBQVNPLE9BQU87WUFDM0I7WUFDQSxPQUFPckMsU0FBU04sSUFBSTtRQUN0QixFQUFFLE9BQU8wQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1lBQy9DLE1BQU0sSUFBSUosTUFBTSwyQkFBb0YsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQ3RGO0lBQ0Y7SUFFQSxNQUFNb0IsaUJBQWlCQyxRQUFnQixFQUFFO1FBQ3ZDLElBQUk7WUFDRixNQUFNdkMsV0FBVyxNQUFNLElBQUksQ0FBQ1QsV0FBVyxDQUFDLFlBQXFCLE9BQVRnRDtZQUNwRCxPQUFPdkMsU0FBU04sSUFBSTtRQUN0QixFQUFFLE9BQU8wQixPQUFPO1lBQ2QsTUFBTSxJQUFJSixNQUFNLGlDQUEwRixPQUF6REksaUJBQWlCSixRQUFRSSxNQUFNRixPQUFPLEdBQUc7UUFDNUY7SUFDRjtJQUVBLE1BQU1zQixpQkFBaUJELFFBQWdCLEVBQUU7UUFDdkMsSUFBSTtZQUNGLE1BQU12QyxXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUMsWUFBcUIsT0FBVGdELFVBQVM7WUFDN0QsT0FBT3ZDLFNBQVNOLElBQUk7UUFDdEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSwyQkFBb0YsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQ3RGO0lBQ0Y7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTXVCLHFCQUFxQkMsV0FBd0IsRUFBRTtRQUNuRCxJQUFJO1lBQ0Ysc0NBQXNDO1lBQ3RDLE1BQU1YLGNBQWMsTUFBTSxJQUFJLENBQUNQLGtCQUFrQjtZQUNqRCxJQUFJLENBQUNPLGFBQWE7Z0JBQ2hCLE1BQU0sSUFBSWYsTUFBTTtZQUNsQjtZQUVBLE1BQU1oQixXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUMsbUJBQW1CLFFBQVE7Z0JBQ2pFb0QsUUFBUUQsWUFBWUMsTUFBTTtnQkFDMUJDLFdBQVdGLFlBQVlFLFNBQVM7Z0JBQ2hDQyxXQUFXSCxZQUFZRyxTQUFTLElBQUk7WUFDdEM7WUFDQSxPQUFPN0MsU0FBU04sSUFBSTtRQUN0QixFQUFFLE9BQU8wQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyw0QkFBNEJBO1lBQzFDLElBQUlBLGlCQUFpQkosU0FBU0ksTUFBTUYsT0FBTyxDQUFDSSxRQUFRLENBQUMsUUFBUTtnQkFDM0QsTUFBTSxJQUFJTixNQUFNO1lBQ2xCO1lBQ0EsTUFBTSxJQUFJQSxNQUFNLDZCQUFzRixPQUF6REksaUJBQWlCSixRQUFRSSxNQUFNRixPQUFPLEdBQUc7UUFDeEY7SUFDRjtJQUVBLE1BQU00Qix1QkFBdUJDLFdBQWlDLEVBQUU7UUFDOUQsSUFBSTtZQUNGLE1BQU0vQyxXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUMsc0JBQXNCLFFBQVE7Z0JBQ3BFb0QsUUFBUUksWUFBWUosTUFBTTtnQkFDMUJLLFVBQVVELFlBQVlDLFFBQVE7Z0JBQzlCSixXQUFXRyxZQUFZSCxTQUFTO2dCQUNoQ0ssTUFBTUYsWUFBWUUsSUFBSSxJQUFJO2dCQUMxQkMsV0FBV0gsWUFBWUcsU0FBUyxJQUFJO1lBQ3RDO1lBQ0EsT0FBT2xELFNBQVNOLElBQUk7UUFDdEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSw0QkFBcUYsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQ3ZGO0lBQ0Y7SUFFQSxNQUFNaUMsb0JBQW9CQyxPQUFlLEVBQUViLFFBQWdCLEVBQUU7UUFDM0QsSUFBSTtZQUNGLE1BQU12QyxXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUMsa0JBQWtCLFFBQVE7Z0JBQ2hFNkQ7Z0JBQ0FiO1lBQ0Y7WUFDQSxPQUFPdkMsU0FBU04sSUFBSTtRQUN0QixFQUFFLE9BQU8wQixPQUFPO1lBQ2QsTUFBTSxJQUFJSixNQUFNLDJCQUFvRixPQUF6REksaUJBQWlCSixRQUFRSSxNQUFNRixPQUFPLEdBQUc7UUFDdEY7SUFDRjtJQUVBLDhCQUE4QjtJQUM5QixNQUFNbUMsWUFBWVgsV0FBOEMsRUFBRTtRQUNoRSxJQUFJO1lBQ0YsTUFBTTFDLFdBQVcsTUFBTSxJQUFJLENBQUNULFdBQVcsQ0FBQyxpQkFBaUIsUUFBUTtnQkFDL0RvRCxRQUFRRCxZQUFZQyxNQUFNO2dCQUMxQk4sU0FBU0ssWUFBWUwsT0FBTztnQkFDNUJPLFdBQVdGLFlBQVlFLFNBQVM7Z0JBQ2hDQyxXQUFXSCxZQUFZRyxTQUFTLElBQUk7WUFDdEM7WUFDQSxPQUFPN0MsU0FBU04sSUFBSTtRQUN0QixFQUFFLE9BQU8wQixPQUFPO1lBQ2QsTUFBTSxJQUFJSixNQUFNLCtCQUF3RixPQUF6REksaUJBQWlCSixRQUFRSSxNQUFNRixPQUFPLEdBQUc7UUFDMUY7SUFDRjtJQUVBLE1BQU1vQyx1QkFBdUJmLFFBQWdCLEVBQUU7UUFDN0MsSUFBSTtZQUNGLE1BQU12QyxXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUMsb0JBQTZCLE9BQVRnRCxXQUFZO1lBQ3hFLE9BQU92QyxTQUFTTixJQUFJO1FBQ3RCLEVBQUUsT0FBTzBCLE9BQU87WUFDZCxNQUFNLElBQUlKLE1BQU0sOEJBQXVGLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUN6RjtJQUNGO0lBRUEsaUJBQWlCO0lBQ2pCLE1BQU1xQyxVQUFVQyxPQUFnQixFQUFFO1FBQ2hDLElBQUk7WUFDRix5REFBeUQ7WUFDekQsTUFBTUMsV0FBVyxJQUFJQztZQUNyQkMsT0FBT0MsT0FBTyxDQUFDSixTQUFTSyxPQUFPLENBQUM7b0JBQUMsQ0FBQ0MsS0FBS0MsTUFBTTtnQkFDM0MsSUFBSUEsaUJBQWlCQyxNQUFNO29CQUN6QlAsU0FBU1EsTUFBTSxDQUFDSCxLQUFLQztnQkFDdkIsT0FBTyxJQUFJQSxPQUFPO29CQUNoQk4sU0FBU1EsTUFBTSxDQUFDSCxLQUFLQyxNQUFNRyxRQUFRO2dCQUNyQztZQUNGO1lBRUEsTUFBTWxFLFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFiLElBQUksQ0FBQ0MsT0FBTyxFQUFDLGdCQUFjO2dCQUN6RFQsUUFBUTtnQkFDUlUsU0FBUztvQkFDUCxpQkFBaUIsVUFBNkIsT0FBbkIsSUFBSSxDQUFDQyxNQUFNLENBQUNDLE1BQU07Z0JBQy9DO2dCQUNBQyxNQUFNbUQ7WUFDUjtZQUVBLElBQUksQ0FBQ3pELFNBQVNZLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNYixTQUFTYyxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSUMsTUFBTSwwQkFBbUUsT0FBekNILFVBQVVLLE9BQU8sSUFBSWxCLFNBQVNtQixVQUFVO1lBQ3BGO1lBRUEsTUFBTWdELFNBQVMsTUFBTW5FLFNBQVNjLElBQUk7WUFDbEMsT0FBT3FELE9BQU96RSxJQUFJO1FBQ3BCLEVBQUUsT0FBTzBCLE9BQU87WUFDZCxNQUFNLElBQUlKLE1BQU0sMEJBQW1GLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUNyRjtJQUNGO0lBRUEsTUFBTWtELGFBQWFDLE1BQWMsRUFBRTtRQUNqQyxJQUFJO1lBQ0YsTUFBTXJFLFdBQVcsTUFBTSxJQUFJLENBQUNULFdBQVcsQ0FBQyxlQUFzQixPQUFQOEU7WUFDdkQsT0FBT3JFLFNBQVNOLElBQUk7UUFDdEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSw0QkFBcUYsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQ3ZGO0lBQ0Y7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTW9ELGlCQUFpQkMsY0FBOEIsRUFBRTtRQUNyRCxJQUFJO1lBQ0YsTUFBTXZFLFdBQVcsTUFBTSxJQUFJLENBQUNULFdBQVcsQ0FBQyxZQUFZLFFBQVE7Z0JBQzFEb0QsUUFBUTRCLGVBQWU1QixNQUFNO2dCQUM3QjZCLGNBQWNELGVBQWVDLFlBQVk7Z0JBQ3pDQyxZQUFZRixlQUFlRSxVQUFVO2dCQUNyQzdCLFdBQVcyQixlQUFlM0IsU0FBUztZQUNyQztZQUNBLE9BQU81QyxTQUFTTixJQUFJO1FBQ3RCLEVBQUUsT0FBTzBCLE9BQU87WUFDZCxNQUFNLElBQUlKLE1BQU0sc0JBQStFLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUNqRjtJQUNGO0lBRUEsTUFBTXdELG1CQUErQztZQUE5QkMsZUFBQUEsaUVBQXVCO1FBQzVDLElBQUk7WUFDRixNQUFNM0UsV0FBVyxNQUFNLElBQUksQ0FBQ1QsV0FBVyxDQUFDLGVBQTRCLE9BQWJvRjtZQUN2RCxPQUFPM0UsU0FBU04sSUFBSTtRQUN0QixFQUFFLE9BQU8wQixPQUFPO1lBQ2QsTUFBTSxJQUFJSixNQUFNLGlDQUEwRixPQUF6REksaUJBQWlCSixRQUFRSSxNQUFNRixPQUFPLEdBQUc7UUFDNUY7SUFDRjtJQUVBLHNCQUFzQjtJQUN0QixNQUFNMEQsc0JBQXNCckMsUUFBZ0IsRUFBMEM7WUFBeENzQyxRQUFBQSxpRUFBZ0IsSUFBSUMsU0FBQUEsaUVBQWlCO1FBQ2pGLElBQUk7WUFDRixNQUFNOUUsV0FBVyxNQUFNLElBQUksQ0FBQ1QsV0FBVyxDQUNyQywwQkFBNENzRixPQUFsQnRDLFVBQVMsV0FBeUJ1QyxPQUFoQkQsT0FBTSxZQUFpQixPQUFQQztZQUU5RCxPQUFPOUUsU0FBU04sSUFBSTtRQUN0QixFQUFFLE9BQU8wQixPQUFPO1lBQ2QsTUFBTSxJQUFJSixNQUFNLHNDQUErRixPQUF6REksaUJBQWlCSixRQUFRSSxNQUFNRixPQUFPLEdBQUc7UUFDakc7SUFDRjtJQUVBLE1BQU02RCxzQkFBc0JDLGFBQXFCLEVBQUU7UUFDakQsSUFBSTtZQUNGLE1BQU1oRixXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUMsaUJBQStCLE9BQWR5RjtZQUN6RCxPQUFPaEYsU0FBU04sSUFBSTtRQUN0QixFQUFFLE9BQU8wQixPQUFPO1lBQ2QsTUFBTSxJQUFJSixNQUFNLHNDQUErRixPQUF6REksaUJBQWlCSixRQUFRSSxNQUFNRixPQUFPLEdBQUc7UUFDakc7SUFDRjtJQUVBLHlDQUF5QztJQUN6QytELHVCQUF1QkMsT0FBZSxFQUFFQyxTQUFpQixFQUFFQyxNQUFjLEVBQVc7UUFDbEYsbUVBQW1FO1FBQ25FLDBEQUEwRDtRQUMxRCxJQUFJO1lBQ0YsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMsZ0dBQVE7WUFDL0IsTUFBTUMsb0JBQW9CRixPQUN2QkcsVUFBVSxDQUFDLFVBQVVKLFFBQ3JCSyxNQUFNLENBQUNQLFNBQ1BRLE1BQU0sQ0FBQztZQUVWLE9BQU9MLE9BQU9NLGVBQWUsQ0FDM0JDLE1BQU1BLENBQUNDLElBQUksQ0FBQ1YsV0FBVyxRQUN2QlMsTUFBTUEsQ0FBQ0MsSUFBSSxDQUFDTixtQkFBbUI7UUFFbkMsRUFBRSxPQUFPbkUsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsMENBQTBDQTtZQUN4RCxPQUFPO1FBQ1Q7SUFDRjtJQUVBLGVBQWU7SUFDZixNQUFNMEUsY0FBYztRQUNsQixJQUFJO1lBQ0YsTUFBTTlGLFdBQVcsTUFBTSxJQUFJLENBQUNULFdBQVcsQ0FBQztZQUN4QyxPQUFPUztRQUNULEVBQUUsT0FBT29CLE9BQU87WUFDZCxNQUFNLElBQUlKLE1BQU0sd0JBQWlGLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUNuRjtJQUNGO0lBN1VBLFlBQVlkLE1BQW9CLENBQUU7UUFDaEMsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRixPQUFPLEdBQUdFLE9BQU9GLE9BQU8sSUFDMUJFLENBQUFBLE9BQU8yRixXQUFXLEtBQUssZUFDcEIsMkJBQ0EsK0JBQThCO0lBQ3RDO0FBd1VGO0FBRUEsc0NBQXNDO0FBQ3RDLElBQUlDLHdCQUE4QztBQUUzQyxTQUFTQyxvQkFBb0I3RixNQUFxQjtJQUN2RCxJQUFJLENBQUM0Rix5QkFBeUI1RixRQUFRO1FBQ3BDLE1BQU1DLFNBQVM2Riw0Q0FBc0MsSUFBSSxDQUFFO1FBQzNELE1BQU1HLGdCQUFnQmpHLFVBQVU7WUFDOUJDO1lBQ0EwRixhQUFhLFNBQTJDLElBQWlDLENBQVM7WUFDbEc3RixTQUFTZ0csOEJBQXVDO1FBQ2xEO1FBRUEsNkJBQTZCO1FBQzdCLElBQUksQ0FBQzdGLFFBQVE7WUFDWGdCLFFBQVFJLElBQUksQ0FBQztRQUNmO1FBRUF1RSx3QkFBd0IsSUFBSTFHLGNBQWMrRztJQUM1QztJQUVBLE9BQU9MO0FBQ1Q7QUFFQSxpQ0FBaUM7QUFDMUIsTUFBTVEsZ0JBQWdCUCxzQkFBc0IiLCJzb3VyY2VzIjpbIi9ob21lL2Vycm9yNTEvYml0bm9iL3Byb2plY3QvdmlsbGFnZS1zYWNjby9zcmMvc2VydmljZXMvYml0bm9iLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCaXRub2IgU2VydmljZSAtIEJsb2NrY2hhaW4gaW50ZWdyYXRpb24gZm9yIFNBQ0NPIHBsYXRmb3JtXG4gKiBIYW5kbGVzIEJpdGNvaW4gTGlnaHRuaW5nIE5ldHdvcmsgcGF5bWVudHMsIHdhbGxldCBvcGVyYXRpb25zLCBhbmQgS1lDXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBCaXRub2JDb25maWcge1xuICBhcGlLZXk6IHN0cmluZztcbiAgZW52aXJvbm1lbnQ6ICdzYW5kYm94JyB8ICdwcm9kdWN0aW9uJztcbiAgYmFzZVVSTD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXYWxsZXREYXRhIHtcbiAgcGhvbmVOdW1iZXI6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgZmlyc3ROYW1lOiBzdHJpbmc7XG4gIGxhc3ROYW1lOiBzdHJpbmc7XG4gIGRhdGVPZkJpcnRoPzogc3RyaW5nO1xuICBhZGRyZXNzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBheW1lbnREYXRhIHtcbiAgYW1vdW50OiBudW1iZXI7XG4gIGN1cnJlbmN5OiBzdHJpbmc7XG4gIHJlY2lwaWVudElkPzogc3RyaW5nO1xuICBwaG9uZU51bWJlcj86IHN0cmluZztcbiAgZW1haWw/OiBzdHJpbmc7XG4gIHJlZmVyZW5jZTogc3RyaW5nO1xuICBuYXJyYXRpb24/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlnaHRuaW5nSW52b2ljZURhdGEge1xuICBhbW91bnQ6IG51bWJlcjtcbiAgY3VycmVuY3k6IHN0cmluZztcbiAgcmVmZXJlbmNlOiBzdHJpbmc7XG4gIG1lbW8/OiBzdHJpbmc7XG4gIGV4cGlyZXNJbj86IG51bWJlcjsgLy8gc2Vjb25kc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEtZQ0RhdGEge1xuICBmaXJzdE5hbWU6IHN0cmluZztcbiAgbGFzdE5hbWU6IHN0cmluZztcbiAgZGF0ZU9mQmlydGg6IHN0cmluZztcbiAgcGhvbmVOdW1iZXI6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICBpZFR5cGU6ICduaW4nIHwgJ3Bhc3Nwb3J0JyB8ICdkcml2ZXJzX2xpY2Vuc2UnO1xuICBpZE51bWJlcjogc3RyaW5nO1xuICBpZERvY3VtZW50PzogRmlsZTtcbiAgcHJvb2ZPZkFkZHJlc3M/OiBGaWxlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNpb25EYXRhIHtcbiAgYW1vdW50OiBudW1iZXI7XG4gIGZyb21DdXJyZW5jeTogc3RyaW5nO1xuICB0b0N1cnJlbmN5OiBzdHJpbmc7XG4gIHJlZmVyZW5jZTogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQml0bm9iU2VydmljZSB7XG4gIHByaXZhdGUgY29uZmlnOiBCaXRub2JDb25maWc7XG4gIHByaXZhdGUgYmFzZVVSTDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogQml0bm9iQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5iYXNlVVJMID0gY29uZmlnLmJhc2VVUkwgfHwgXG4gICAgICAoY29uZmlnLmVudmlyb25tZW50ID09PSAncHJvZHVjdGlvbicgXG4gICAgICAgID8gJ2h0dHBzOi8vYXBpLmJpdG5vYi5jb20nIFxuICAgICAgICA6ICdodHRwczovL3NhbmRib3hhcGkuYml0bm9iLmNvbScpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBtYWtlUmVxdWVzdChlbmRwb2ludDogc3RyaW5nLCBtZXRob2Q6IHN0cmluZyA9ICdHRVQnLCBkYXRhPzogYW55KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSB0aW1lb3V0IGNvbnRyb2xsZXJcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgMTAwMDApOyAvLyAxMCBzZWNvbmQgdGltZW91dFxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0ke2VuZHBvaW50fWAsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YCxcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBkYXRhID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiB1bmRlZmluZWQsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICB9KTtcblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdG5vYiBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAtICR7ZXJyb3JEYXRhLm1lc3NhZ2UgfHwgcmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQml0bm9iIFNlcnZpY2UgRXJyb3I6JywgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgc3BlY2lmaWMgbmV0d29yayBlcnJvcnNcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdnZXRhZGRyaW5mbyBFTk9URk9VTkQnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdmZXRjaCBmYWlsZWQnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQml0bm9iIHNlcnZpY2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdG5vYiBzZXJ2aWNlIHJlcXVlc3QgdGltZWQgb3V0LiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGlmIEJpdG5vYiBzZXJ2aWNlIGlzIGF2YWlsYWJsZVxuICBhc3luYyBpc1NlcnZpY2VBdmFpbGFibGUoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIEFQSSBrZXkgaXMgY29uZmlndXJlZFxuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5hcGlLZXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdCaXRub2IgQVBJIGtleSBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFRlc3Qgd2l0aCBoZWFsdGggZW5kcG9pbnRcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2hlYWx0aCcpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlICYmIHJlc3BvbnNlLnN0YXR1cyA9PT0gJ29rJztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQml0bm9iIHNlcnZpY2UgYXZhaWxhYmlsaXR5IGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gVGVzdCBhdmFpbGFibGUgZW5kcG9pbnRzXG4gIGFzeW5jIHRlc3RFbmRwb2ludHMoKTogUHJvbWlzZTx7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfT4ge1xuICAgIGNvbnN0IGVuZHBvaW50cyA9IFtcbiAgICAgICcvaGVhbHRoJyxcbiAgICAgICcvcGluZycsIFxuICAgICAgJy93YWxsZXRzJyxcbiAgICAgICcvbGlnaHRuaW5nL2ludm9pY2UnLFxuICAgICAgJy9saWdodG5pbmcvc2VuZCcsXG4gICAgICAnL2JpdGNvaW4vc2VuZCcsXG4gICAgICAnL3JhdGVzJ1xuICAgIF07XG5cbiAgICBjb25zdCByZXN1bHRzOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBlbmRwb2ludCBvZiBlbmRwb2ludHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfSR7ZW5kcG9pbnR9YCwge1xuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy5jb25maWcuYXBpS2V5fWAsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHRzW2VuZHBvaW50XSA9IHJlc3BvbnNlLnN0YXR1cyAhPT0gNDA0O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0c1tlbmRwb2ludF0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8vIEF1dGhlbnRpY2F0aW9uIGFuZCBVc2VyIE1hbmFnZW1lbnRcbiAgYXN5bmMgY3JlYXRlV2FsbGV0KHVzZXJEYXRhOiBXYWxsZXREYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHNlcnZpY2UgaXMgYXZhaWxhYmxlXG4gICAgICBjb25zdCBpc0F2YWlsYWJsZSA9IGF3YWl0IHRoaXMuaXNTZXJ2aWNlQXZhaWxhYmxlKCk7XG4gICAgICBpZiAoIWlzQXZhaWxhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQml0bm9iIHNlcnZpY2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL3dhbGxldHMvY3JlYXRlJywgJ1BPU1QnLCB7XG4gICAgICAgIHBob25lTnVtYmVyOiB1c2VyRGF0YS5waG9uZU51bWJlcixcbiAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICBmaXJzdE5hbWU6IHVzZXJEYXRhLmZpcnN0TmFtZSxcbiAgICAgICAgbGFzdE5hbWU6IHVzZXJEYXRhLmxhc3ROYW1lLFxuICAgICAgICBkYXRlT2ZCaXJ0aDogdXNlckRhdGEuZGF0ZU9mQmlydGgsXG4gICAgICAgIGFkZHJlc3M6IHVzZXJEYXRhLmFkZHJlc3MsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdCaXRub2Igd2FsbGV0IGNyZWF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgV2FsbGV0IGNyZWF0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRXYWxsZXREZXRhaWxzKHdhbGxldElkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAvd2FsbGV0cy8ke3dhbGxldElkfWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB3YWxsZXQgZGV0YWlsczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRXYWxsZXRCYWxhbmNlKHdhbGxldElkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAvd2FsbGV0cy8ke3dhbGxldElkfS9iYWxhbmNlYCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWxhbmNlIGlucXVpcnkgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIExpZ2h0bmluZyBOZXR3b3JrIE9wZXJhdGlvbnNcbiAgYXN5bmMgc2VuZExpZ2h0bmluZ1BheW1lbnQocGF5bWVudERhdGE6IFBheW1lbnREYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHNlcnZpY2UgaXMgYXZhaWxhYmxlIGZpcnN0XG4gICAgICBjb25zdCBpc0F2YWlsYWJsZSA9IGF3YWl0IHRoaXMuaXNTZXJ2aWNlQXZhaWxhYmxlKCk7XG4gICAgICBpZiAoIWlzQXZhaWxhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQml0bm9iIHNlcnZpY2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy9saWdodG5pbmcvc2VuZCcsICdQT1NUJywge1xuICAgICAgICBhbW91bnQ6IHBheW1lbnREYXRhLmFtb3VudCxcbiAgICAgICAgcmVmZXJlbmNlOiBwYXltZW50RGF0YS5yZWZlcmVuY2UsXG4gICAgICAgIG5hcnJhdGlvbjogcGF5bWVudERhdGEubmFycmF0aW9uIHx8ICdTQUNDTyBQbGF0Zm9ybSBQYXltZW50JyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xpZ2h0bmluZyBwYXltZW50IGVycm9yOicsIGVycm9yKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJzQwNCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGlnaHRuaW5nIHBheW1lbnQgc2VydmljZSBpcyB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZS4gVGhlIEFQSSBlbmRwb2ludCBtYXkgaGF2ZSBjaGFuZ2VkLiBQbGVhc2UgY29udGFjdCBzdXBwb3J0LicpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaWdodG5pbmcgcGF5bWVudCBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlTGlnaHRuaW5nSW52b2ljZShpbnZvaWNlRGF0YTogTGlnaHRuaW5nSW52b2ljZURhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCcvbGlnaHRuaW5nL2ludm9pY2UnLCAnUE9TVCcsIHtcbiAgICAgICAgYW1vdW50OiBpbnZvaWNlRGF0YS5hbW91bnQsXG4gICAgICAgIGN1cnJlbmN5OiBpbnZvaWNlRGF0YS5jdXJyZW5jeSxcbiAgICAgICAgcmVmZXJlbmNlOiBpbnZvaWNlRGF0YS5yZWZlcmVuY2UsXG4gICAgICAgIG1lbW86IGludm9pY2VEYXRhLm1lbW8gfHwgJ1NBQ0NPIFBsYXRmb3JtIFBheW1lbnQnLFxuICAgICAgICBleHBpcmVzSW46IGludm9pY2VEYXRhLmV4cGlyZXNJbiB8fCAzNjAwLCAvLyAxIGhvdXIgZGVmYXVsdFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZvaWNlIGNyZWF0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBwYXlMaWdodG5pbmdJbnZvaWNlKGludm9pY2U6IHN0cmluZywgd2FsbGV0SWQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy9saWdodG5pbmcvcGF5JywgJ1BPU1QnLCB7XG4gICAgICAgIGludm9pY2UsXG4gICAgICAgIHdhbGxldElkLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZvaWNlIHBheW1lbnQgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJpdGNvaW4gT24tQ2hhaW4gT3BlcmF0aW9uc1xuICBhc3luYyBzZW5kQml0Y29pbihwYXltZW50RGF0YTogUGF5bWVudERhdGEgJiB7IGFkZHJlc3M6IHN0cmluZyB9KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2JpdGNvaW4vc2VuZCcsICdQT1NUJywge1xuICAgICAgICBhbW91bnQ6IHBheW1lbnREYXRhLmFtb3VudCxcbiAgICAgICAgYWRkcmVzczogcGF5bWVudERhdGEuYWRkcmVzcyxcbiAgICAgICAgcmVmZXJlbmNlOiBwYXltZW50RGF0YS5yZWZlcmVuY2UsXG4gICAgICAgIG5hcnJhdGlvbjogcGF5bWVudERhdGEubmFycmF0aW9uIHx8ICdTQUNDTyBQbGF0Zm9ybSBQYXltZW50JyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQml0Y29pbiB0cmFuc2FjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2VuZXJhdGVCaXRjb2luQWRkcmVzcyh3YWxsZXRJZDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgL2JpdGNvaW4vYWRkcmVzcy8ke3dhbGxldElkfWAsICdQT1NUJyk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzIGdlbmVyYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEtZQyBPcGVyYXRpb25zXG4gIGFzeW5jIHN1Ym1pdEtZQyhreWNEYXRhOiBLWUNEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE5vdGU6IEZpbGUgdXBsb2FkcyB3b3VsZCBuZWVkIEZvcm1EYXRhIGluc3RlYWQgb2YgSlNPTlxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGt5Y0RhdGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0va3ljL3N1Ym1pdGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YCxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS1lDIHN1Ym1pc3Npb24gZmFpbGVkOiAke2Vycm9yRGF0YS5tZXNzYWdlIHx8IHJlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLWUMgc3VibWlzc2lvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0S1lDU3RhdHVzKHVzZXJJZDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgL2t5Yy9zdGF0dXMvJHt1c2VySWR9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLWUMgc3RhdHVzIGNoZWNrIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICAvLyBDdXJyZW5jeSBDb252ZXJzaW9uXG4gIGFzeW5jIGNvbnZlcnRCVENUb0ZpYXQoY29udmVyc2lvbkRhdGE6IENvbnZlcnNpb25EYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2NvbnZlcnQnLCAnUE9TVCcsIHtcbiAgICAgICAgYW1vdW50OiBjb252ZXJzaW9uRGF0YS5hbW91bnQsXG4gICAgICAgIGZyb21DdXJyZW5jeTogY29udmVyc2lvbkRhdGEuZnJvbUN1cnJlbmN5LFxuICAgICAgICB0b0N1cnJlbmN5OiBjb252ZXJzaW9uRGF0YS50b0N1cnJlbmN5LFxuICAgICAgICByZWZlcmVuY2U6IGNvbnZlcnNpb25EYXRhLnJlZmVyZW5jZSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udmVyc2lvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0RXhjaGFuZ2VSYXRlcyhiYXNlQ3VycmVuY3k6IHN0cmluZyA9ICdCVEMnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgL3JhdGVzP2Jhc2U9JHtiYXNlQ3VycmVuY3l9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IGV4Y2hhbmdlIHJhdGVzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyYW5zYWN0aW9uIEhpc3RvcnlcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25IaXN0b3J5KHdhbGxldElkOiBzdHJpbmcsIGxpbWl0OiBudW1iZXIgPSA1MCwgb2Zmc2V0OiBudW1iZXIgPSAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChcbiAgICAgICAgYC90cmFuc2FjdGlvbnM/d2FsbGV0SWQ9JHt3YWxsZXRJZH0mbGltaXQ9JHtsaW1pdH0mb2Zmc2V0PSR7b2Zmc2V0fWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uIGhpc3Rvcnk6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25EZXRhaWxzKHRyYW5zYWN0aW9uSWQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYC90cmFuc2FjdGlvbnMvJHt0cmFuc2FjdGlvbklkfWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbiBkZXRhaWxzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlYmhvb2sgdmVyaWZpY2F0aW9uIChmb3IgYmFja2VuZCB1c2UpXG4gIHZlcmlmeVdlYmhvb2tTaWduYXR1cmUocGF5bG9hZDogc3RyaW5nLCBzaWduYXR1cmU6IHN0cmluZywgc2VjcmV0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiB3b3VsZCBkZXBlbmQgb24gQml0bm9iJ3Mgd2ViaG9vayBzaWduYXR1cmUgbWV0aG9kXG4gICAgLy8gVGhpcyBpcyBhIHBsYWNlaG9sZGVyIGZvciB0aGUgYWN0dWFsIHZlcmlmaWNhdGlvbiBsb2dpY1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkU2lnbmF0dXJlID0gY3J5cHRvXG4gICAgICAgIC5jcmVhdGVIbWFjKCdzaGEyNTYnLCBzZWNyZXQpXG4gICAgICAgIC51cGRhdGUocGF5bG9hZClcbiAgICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICBcbiAgICAgIHJldHVybiBjcnlwdG8udGltaW5nU2FmZUVxdWFsKFxuICAgICAgICBCdWZmZXIuZnJvbShzaWduYXR1cmUsICdoZXgnKSxcbiAgICAgICAgQnVmZmVyLmZyb20oZXhwZWN0ZWRTaWduYXR1cmUsICdoZXgnKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignV2ViaG9vayBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gSGVhbHRoIGNoZWNrXG4gIGFzeW5jIGhlYWx0aENoZWNrKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy9oZWFsdGgnKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIZWFsdGggY2hlY2sgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBTaW5nbGV0b24gaW5zdGFuY2UgZm9yIGZyb250ZW5kIHVzZVxubGV0IGJpdG5vYlNlcnZpY2VJbnN0YW5jZTogQml0bm9iU2VydmljZSB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQml0bm9iU2VydmljZShjb25maWc/OiBCaXRub2JDb25maWcpOiBCaXRub2JTZXJ2aWNlIHtcbiAgaWYgKCFiaXRub2JTZXJ2aWNlSW5zdGFuY2UgfHwgY29uZmlnKSB7XG4gICAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQklUTk9CX0FQSV9LRVkgfHwgJyc7XG4gICAgY29uc3Qgc2VydmljZUNvbmZpZyA9IGNvbmZpZyB8fCB7XG4gICAgICBhcGlLZXksXG4gICAgICBlbnZpcm9ubWVudDogKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JJVE5PQl9FTlZJUk9OTUVOVCBhcyAnc2FuZGJveCcgfCAncHJvZHVjdGlvbicpIHx8ICdzYW5kYm94JyxcbiAgICAgIGJhc2VVUkw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JJVE5PQl9CQVNFX1VSTCxcbiAgICB9O1xuXG4gICAgLy8gV2FybiBpZiBBUEkga2V5IGlzIG1pc3NpbmdcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgY29uc29sZS53YXJuKCdCaXRub2IgQVBJIGtleSBub3QgY29uZmlndXJlZC4gQml0Y29pbiB3YWxsZXQgZmVhdHVyZXMgd2lsbCBiZSBkaXNhYmxlZC4nKTtcbiAgICB9XG5cbiAgICBiaXRub2JTZXJ2aWNlSW5zdGFuY2UgPSBuZXcgQml0bm9iU2VydmljZShzZXJ2aWNlQ29uZmlnKTtcbiAgfVxuXG4gIHJldHVybiBiaXRub2JTZXJ2aWNlSW5zdGFuY2U7XG59XG5cbi8vIERlZmF1bHQgZXhwb3J0IGZvciBjb252ZW5pZW5jZVxuZXhwb3J0IGNvbnN0IGJpdG5vYlNlcnZpY2UgPSBjcmVhdGVCaXRub2JTZXJ2aWNlKCk7XG4iXSwibmFtZXMiOlsiQml0bm9iU2VydmljZSIsIm1ha2VSZXF1ZXN0IiwiZW5kcG9pbnQiLCJtZXRob2QiLCJkYXRhIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJiYXNlVVJMIiwiaGVhZGVycyIsImNvbmZpZyIsImFwaUtleSIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidW5kZWZpbmVkIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJFcnJvciIsInN0YXR1cyIsIm1lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiZXJyb3IiLCJjb25zb2xlIiwiaW5jbHVkZXMiLCJuYW1lIiwiaXNTZXJ2aWNlQXZhaWxhYmxlIiwid2FybiIsInRlc3RFbmRwb2ludHMiLCJlbmRwb2ludHMiLCJyZXN1bHRzIiwiY3JlYXRlV2FsbGV0IiwidXNlckRhdGEiLCJpc0F2YWlsYWJsZSIsInBob25lTnVtYmVyIiwiZW1haWwiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImRhdGVPZkJpcnRoIiwiYWRkcmVzcyIsImdldFdhbGxldERldGFpbHMiLCJ3YWxsZXRJZCIsImdldFdhbGxldEJhbGFuY2UiLCJzZW5kTGlnaHRuaW5nUGF5bWVudCIsInBheW1lbnREYXRhIiwiYW1vdW50IiwicmVmZXJlbmNlIiwibmFycmF0aW9uIiwiY3JlYXRlTGlnaHRuaW5nSW52b2ljZSIsImludm9pY2VEYXRhIiwiY3VycmVuY3kiLCJtZW1vIiwiZXhwaXJlc0luIiwicGF5TGlnaHRuaW5nSW52b2ljZSIsImludm9pY2UiLCJzZW5kQml0Y29pbiIsImdlbmVyYXRlQml0Y29pbkFkZHJlc3MiLCJzdWJtaXRLWUMiLCJreWNEYXRhIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJGaWxlIiwiYXBwZW5kIiwidG9TdHJpbmciLCJyZXN1bHQiLCJnZXRLWUNTdGF0dXMiLCJ1c2VySWQiLCJjb252ZXJ0QlRDVG9GaWF0IiwiY29udmVyc2lvbkRhdGEiLCJmcm9tQ3VycmVuY3kiLCJ0b0N1cnJlbmN5IiwiZ2V0RXhjaGFuZ2VSYXRlcyIsImJhc2VDdXJyZW5jeSIsImdldFRyYW5zYWN0aW9uSGlzdG9yeSIsImxpbWl0Iiwib2Zmc2V0IiwiZ2V0VHJhbnNhY3Rpb25EZXRhaWxzIiwidHJhbnNhY3Rpb25JZCIsInZlcmlmeVdlYmhvb2tTaWduYXR1cmUiLCJwYXlsb2FkIiwic2lnbmF0dXJlIiwic2VjcmV0IiwiY3J5cHRvIiwicmVxdWlyZSIsImV4cGVjdGVkU2lnbmF0dXJlIiwiY3JlYXRlSG1hYyIsInVwZGF0ZSIsImRpZ2VzdCIsInRpbWluZ1NhZmVFcXVhbCIsIkJ1ZmZlciIsImZyb20iLCJoZWFsdGhDaGVjayIsImVudmlyb25tZW50IiwiYml0bm9iU2VydmljZUluc3RhbmNlIiwiY3JlYXRlQml0bm9iU2VydmljZSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19CSVROT0JfQVBJX0tFWSIsInNlcnZpY2VDb25maWciLCJORVhUX1BVQkxJQ19CSVROT0JfRU5WSVJPTk1FTlQiLCJORVhUX1BVQkxJQ19CSVROT0JfQkFTRV9VUkwiLCJiaXRub2JTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/bitnob.service.ts\n"));

/***/ })

});