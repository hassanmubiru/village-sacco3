"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/services/bitnob.service.ts":
/*!****************************************!*\
  !*** ./src/services/bitnob.service.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BitnobService: () => (/* binding */ BitnobService),\n/* harmony export */   bitnobService: () => (/* binding */ bitnobService),\n/* harmony export */   createBitnobService: () => (/* binding */ createBitnobService)\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/**\n * Bitnob Service - Blockchain integration for SACCO platform\n * Handles Bitcoin Lightning Network payments, wallet operations, and KYC\n */ class BitnobService {\n    async makeRequest(endpoint) {\n        let method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'GET', data = arguments.length > 2 ? arguments[2] : void 0;\n        try {\n            // Create timeout controller\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 10000); // 10 second timeout\n            const response = await fetch(\"\".concat(this.baseURL).concat(endpoint), {\n                method,\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(this.config.apiKey),\n                    'Accept': 'application/json'\n                },\n                body: data ? JSON.stringify(data) : undefined,\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(\"Bitnob API Error: \".concat(response.status, \" - \").concat(errorData.message || response.statusText));\n            }\n            return await response.json();\n        } catch (error) {\n            console.error('Bitnob Service Error:', error);\n            // Handle specific network errors\n            if (error instanceof Error) {\n                if (error.message.includes('getaddrinfo ENOTFOUND') || error.message.includes('fetch failed')) {\n                    throw new Error('Bitnob service is currently unavailable. Please try again later.');\n                }\n                if (error.name === 'AbortError') {\n                    throw new Error('Bitnob service request timed out. Please try again.');\n                }\n            }\n            throw error;\n        }\n    }\n    // Check if Bitnob service is available\n    async isServiceAvailable() {\n        try {\n            // Check if API key is configured\n            if (!this.config.apiKey) {\n                console.warn('Bitnob API key not configured');\n                return false;\n            }\n            // Try a simple ping/health check\n            await this.makeRequest('/ping');\n            return true;\n        } catch (error) {\n            console.warn('Bitnob service unavailable:', error);\n            return false;\n        }\n    }\n    // Authentication and User Management\n    async createWallet(userData) {\n        try {\n            // First check if service is available\n            const isAvailable = await this.isServiceAvailable();\n            if (!isAvailable) {\n                throw new Error('Bitnob service is currently unavailable');\n            }\n            const response = await this.makeRequest('/wallets/create', 'POST', {\n                phoneNumber: userData.phoneNumber,\n                email: userData.email,\n                firstName: userData.firstName,\n                lastName: userData.lastName,\n                dateOfBirth: userData.dateOfBirth,\n                address: userData.address\n            });\n            return response.data;\n        } catch (error) {\n            console.error('Bitnob wallet creation error:', error);\n            throw new Error(\"Wallet creation failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getWalletDetails(walletId) {\n        try {\n            const response = await this.makeRequest(\"/wallets/\".concat(walletId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get wallet details: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getWalletBalance(walletId) {\n        try {\n            const response = await this.makeRequest(\"/wallets/\".concat(walletId, \"/balance\"));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Balance inquiry failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Lightning Network Operations\n    async sendLightningPayment(paymentData) {\n        try {\n            const response = await this.makeRequest('/lightning/send', 'POST', {\n                amount: paymentData.amount,\n                currency: paymentData.currency,\n                recipientId: paymentData.recipientId,\n                phoneNumber: paymentData.phoneNumber,\n                email: paymentData.email,\n                reference: paymentData.reference,\n                narration: paymentData.narration || 'SACCO Platform Payment'\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Lightning payment failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async createLightningInvoice(invoiceData) {\n        try {\n            const response = await this.makeRequest('/lightning/invoice', 'POST', {\n                amount: invoiceData.amount,\n                currency: invoiceData.currency,\n                reference: invoiceData.reference,\n                memo: invoiceData.memo || 'SACCO Platform Payment',\n                expiresIn: invoiceData.expiresIn || 3600\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Invoice creation failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async payLightningInvoice(invoice, walletId) {\n        try {\n            const response = await this.makeRequest('/lightning/pay', 'POST', {\n                invoice,\n                walletId\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Invoice payment failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Bitcoin On-Chain Operations\n    async sendBitcoin(paymentData) {\n        try {\n            const response = await this.makeRequest('/bitcoin/send', 'POST', {\n                amount: paymentData.amount,\n                address: paymentData.address,\n                reference: paymentData.reference,\n                narration: paymentData.narration || 'SACCO Platform Payment'\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Bitcoin transaction failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async generateBitcoinAddress(walletId) {\n        try {\n            const response = await this.makeRequest(\"/bitcoin/address/\".concat(walletId), 'POST');\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Address generation failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // KYC Operations\n    async submitKYC(kycData) {\n        try {\n            // Note: File uploads would need FormData instead of JSON\n            const formData = new FormData();\n            Object.entries(kycData).forEach((param)=>{\n                let [key, value] = param;\n                if (value instanceof File) {\n                    formData.append(key, value);\n                } else if (value) {\n                    formData.append(key, value.toString());\n                }\n            });\n            const response = await fetch(\"\".concat(this.baseURL, \"/kyc/submit\"), {\n                method: 'POST',\n                headers: {\n                    'Authorization': \"Bearer \".concat(this.config.apiKey)\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(\"KYC submission failed: \".concat(errorData.message || response.statusText));\n            }\n            const result = await response.json();\n            return result.data;\n        } catch (error) {\n            throw new Error(\"KYC submission failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getKYCStatus(userId) {\n        try {\n            const response = await this.makeRequest(\"/kyc/status/\".concat(userId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"KYC status check failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Currency Conversion\n    async convertBTCToFiat(conversionData) {\n        try {\n            const response = await this.makeRequest('/convert', 'POST', {\n                amount: conversionData.amount,\n                fromCurrency: conversionData.fromCurrency,\n                toCurrency: conversionData.toCurrency,\n                reference: conversionData.reference\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Conversion failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getExchangeRates() {\n        let baseCurrency = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'BTC';\n        try {\n            const response = await this.makeRequest(\"/rates?base=\".concat(baseCurrency));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get exchange rates: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Transaction History\n    async getTransactionHistory(walletId) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50, offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        try {\n            const response = await this.makeRequest(\"/transactions?walletId=\".concat(walletId, \"&limit=\").concat(limit, \"&offset=\").concat(offset));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get transaction history: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    async getTransactionDetails(transactionId) {\n        try {\n            const response = await this.makeRequest(\"/transactions/\".concat(transactionId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get transaction details: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    // Webhook verification (for backend use)\n    verifyWebhookSignature(payload, signature, secret) {\n        // Implementation would depend on Bitnob's webhook signature method\n        // This is a placeholder for the actual verification logic\n        try {\n            const crypto = __webpack_require__(/*! crypto */ \"(app-pages-browser)/./node_modules/next/dist/compiled/crypto-browserify/index.js\");\n            const expectedSignature = crypto.createHmac('sha256', secret).update(payload).digest('hex');\n            return crypto.timingSafeEqual(Buffer.from(signature, 'hex'), Buffer.from(expectedSignature, 'hex'));\n        } catch (error) {\n            console.error('Webhook signature verification failed:', error);\n            return false;\n        }\n    }\n    // Health check\n    async healthCheck() {\n        try {\n            const response = await this.makeRequest('/health');\n            return response;\n        } catch (error) {\n            throw new Error(\"Health check failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    constructor(config){\n        this.config = config;\n        this.baseURL = config.baseURL || (config.environment === 'production' ? 'https://api.bitnob.com' : 'https://sandboxapi.bitnob.com');\n    }\n}\n// Singleton instance for frontend use\nlet bitnobServiceInstance = null;\nfunction createBitnobService(config) {\n    if (!bitnobServiceInstance || config) {\n        const apiKey = \"hsk.d550cb2465fe.d92cf979e734a2baae0470a48\" || 0;\n        const serviceConfig = config || {\n            apiKey,\n            environment: \"sandbox\" || 0,\n            baseURL: \"https://sandboxapi.bitnob.co\"\n        };\n        // Warn if API key is missing\n        if (!apiKey) {\n            console.warn('Bitnob API key not configured. Bitcoin wallet features will be disabled.');\n        }\n        bitnobServiceInstance = new BitnobService(serviceConfig);\n    }\n    return bitnobServiceInstance;\n}\n// Default export for convenience\nconst bitnobService = createBitnobService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9iaXRub2Iuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7OztDQUdDLEdBdURNLE1BQU1BO0lBWVgsTUFBY0MsWUFBWUMsUUFBZ0IsRUFBc0M7WUFBcENDLFNBQUFBLGlFQUFpQixPQUFPQztRQUNsRSxJQUFJO1lBQ0YsNEJBQTRCO1lBQzVCLE1BQU1DLGFBQWEsSUFBSUM7WUFDdkIsTUFBTUMsWUFBWUMsV0FBVyxJQUFNSCxXQUFXSSxLQUFLLElBQUksUUFBUSxvQkFBb0I7WUFFbkYsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQWtCVCxPQUFmLElBQUksQ0FBQ1UsT0FBTyxFQUFZLE9BQVRWLFdBQVk7Z0JBQ3pEQztnQkFDQVUsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLGlCQUFpQixVQUE2QixPQUFuQixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsTUFBTTtvQkFDN0MsVUFBVTtnQkFDWjtnQkFDQUMsTUFBTVosT0FBT2EsS0FBS0MsU0FBUyxDQUFDZCxRQUFRZTtnQkFDcENDLFFBQVFmLFdBQVdlLE1BQU07WUFDM0I7WUFFQUMsYUFBYWQ7WUFFYixJQUFJLENBQUNHLFNBQVNZLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNYixTQUFTYyxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSUMsTUFBTSxxQkFBMENILE9BQXJCYixTQUFTaUIsTUFBTSxFQUFDLE9BQThDLE9BQXpDSixVQUFVSyxPQUFPLElBQUlsQixTQUFTbUIsVUFBVTtZQUNwRztZQUVBLE9BQU8sTUFBTW5CLFNBQVNjLElBQUk7UUFDNUIsRUFBRSxPQUFPTSxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyx5QkFBeUJBO1lBRXZDLGlDQUFpQztZQUNqQyxJQUFJQSxpQkFBaUJKLE9BQU87Z0JBQzFCLElBQUlJLE1BQU1GLE9BQU8sQ0FBQ0ksUUFBUSxDQUFDLDRCQUE0QkYsTUFBTUYsT0FBTyxDQUFDSSxRQUFRLENBQUMsaUJBQWlCO29CQUM3RixNQUFNLElBQUlOLE1BQU07Z0JBQ2xCO2dCQUNBLElBQUlJLE1BQU1HLElBQUksS0FBSyxjQUFjO29CQUMvQixNQUFNLElBQUlQLE1BQU07Z0JBQ2xCO1lBQ0Y7WUFFQSxNQUFNSTtRQUNSO0lBQ0Y7SUFFQSx1Q0FBdUM7SUFDdkMsTUFBTUkscUJBQXVDO1FBQzNDLElBQUk7WUFDRixpQ0FBaUM7WUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQ0MsTUFBTSxFQUFFO2dCQUN2QmdCLFFBQVFJLElBQUksQ0FBQztnQkFDYixPQUFPO1lBQ1Q7WUFFQSxpQ0FBaUM7WUFDakMsTUFBTSxJQUFJLENBQUNsQyxXQUFXLENBQUM7WUFDdkIsT0FBTztRQUNULEVBQUUsT0FBTzZCLE9BQU87WUFDZEMsUUFBUUksSUFBSSxDQUFDLCtCQUErQkw7WUFDNUMsT0FBTztRQUNUO0lBQ0Y7SUFFQSxxQ0FBcUM7SUFDckMsTUFBTU0sYUFBYUMsUUFBb0IsRUFBRTtRQUN2QyxJQUFJO1lBQ0Ysc0NBQXNDO1lBQ3RDLE1BQU1DLGNBQWMsTUFBTSxJQUFJLENBQUNKLGtCQUFrQjtZQUNqRCxJQUFJLENBQUNJLGFBQWE7Z0JBQ2hCLE1BQU0sSUFBSVosTUFBTTtZQUNsQjtZQUVBLE1BQU1oQixXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUMsbUJBQW1CLFFBQVE7Z0JBQ2pFc0MsYUFBYUYsU0FBU0UsV0FBVztnQkFDakNDLE9BQU9ILFNBQVNHLEtBQUs7Z0JBQ3JCQyxXQUFXSixTQUFTSSxTQUFTO2dCQUM3QkMsVUFBVUwsU0FBU0ssUUFBUTtnQkFDM0JDLGFBQWFOLFNBQVNNLFdBQVc7Z0JBQ2pDQyxTQUFTUCxTQUFTTyxPQUFPO1lBQzNCO1lBQ0EsT0FBT2xDLFNBQVNOLElBQUk7UUFDdEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyxNQUFNLElBQUlKLE1BQU0sMkJBQW9GLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUN0RjtJQUNGO0lBRUEsTUFBTWlCLGlCQUFpQkMsUUFBZ0IsRUFBRTtRQUN2QyxJQUFJO1lBQ0YsTUFBTXBDLFdBQVcsTUFBTSxJQUFJLENBQUNULFdBQVcsQ0FBQyxZQUFxQixPQUFUNkM7WUFDcEQsT0FBT3BDLFNBQVNOLElBQUk7UUFDdEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSxpQ0FBMEYsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQzVGO0lBQ0Y7SUFFQSxNQUFNbUIsaUJBQWlCRCxRQUFnQixFQUFFO1FBQ3ZDLElBQUk7WUFDRixNQUFNcEMsV0FBVyxNQUFNLElBQUksQ0FBQ1QsV0FBVyxDQUFDLFlBQXFCLE9BQVQ2QyxVQUFTO1lBQzdELE9BQU9wQyxTQUFTTixJQUFJO1FBQ3RCLEVBQUUsT0FBTzBCLE9BQU87WUFDZCxNQUFNLElBQUlKLE1BQU0sMkJBQW9GLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUN0RjtJQUNGO0lBRUEsK0JBQStCO0lBQy9CLE1BQU1vQixxQkFBcUJDLFdBQXdCLEVBQUU7UUFDbkQsSUFBSTtZQUNGLE1BQU12QyxXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUMsbUJBQW1CLFFBQVE7Z0JBQ2pFaUQsUUFBUUQsWUFBWUMsTUFBTTtnQkFDMUJDLFVBQVVGLFlBQVlFLFFBQVE7Z0JBQzlCQyxhQUFhSCxZQUFZRyxXQUFXO2dCQUNwQ2IsYUFBYVUsWUFBWVYsV0FBVztnQkFDcENDLE9BQU9TLFlBQVlULEtBQUs7Z0JBQ3hCYSxXQUFXSixZQUFZSSxTQUFTO2dCQUNoQ0MsV0FBV0wsWUFBWUssU0FBUyxJQUFJO1lBQ3RDO1lBQ0EsT0FBTzVDLFNBQVNOLElBQUk7UUFDdEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSw2QkFBc0YsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQ3hGO0lBQ0Y7SUFFQSxNQUFNMkIsdUJBQXVCQyxXQUFpQyxFQUFFO1FBQzlELElBQUk7WUFDRixNQUFNOUMsV0FBVyxNQUFNLElBQUksQ0FBQ1QsV0FBVyxDQUFDLHNCQUFzQixRQUFRO2dCQUNwRWlELFFBQVFNLFlBQVlOLE1BQU07Z0JBQzFCQyxVQUFVSyxZQUFZTCxRQUFRO2dCQUM5QkUsV0FBV0csWUFBWUgsU0FBUztnQkFDaENJLE1BQU1ELFlBQVlDLElBQUksSUFBSTtnQkFDMUJDLFdBQVdGLFlBQVlFLFNBQVMsSUFBSTtZQUN0QztZQUNBLE9BQU9oRCxTQUFTTixJQUFJO1FBQ3RCLEVBQUUsT0FBTzBCLE9BQU87WUFDZCxNQUFNLElBQUlKLE1BQU0sNEJBQXFGLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUN2RjtJQUNGO0lBRUEsTUFBTStCLG9CQUFvQkMsT0FBZSxFQUFFZCxRQUFnQixFQUFFO1FBQzNELElBQUk7WUFDRixNQUFNcEMsV0FBVyxNQUFNLElBQUksQ0FBQ1QsV0FBVyxDQUFDLGtCQUFrQixRQUFRO2dCQUNoRTJEO2dCQUNBZDtZQUNGO1lBQ0EsT0FBT3BDLFNBQVNOLElBQUk7UUFDdEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSwyQkFBb0YsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQ3RGO0lBQ0Y7SUFFQSw4QkFBOEI7SUFDOUIsTUFBTWlDLFlBQVlaLFdBQThDLEVBQUU7UUFDaEUsSUFBSTtZQUNGLE1BQU12QyxXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUMsaUJBQWlCLFFBQVE7Z0JBQy9EaUQsUUFBUUQsWUFBWUMsTUFBTTtnQkFDMUJOLFNBQVNLLFlBQVlMLE9BQU87Z0JBQzVCUyxXQUFXSixZQUFZSSxTQUFTO2dCQUNoQ0MsV0FBV0wsWUFBWUssU0FBUyxJQUFJO1lBQ3RDO1lBQ0EsT0FBTzVDLFNBQVNOLElBQUk7UUFDdEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSwrQkFBd0YsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQzFGO0lBQ0Y7SUFFQSxNQUFNa0MsdUJBQXVCaEIsUUFBZ0IsRUFBRTtRQUM3QyxJQUFJO1lBQ0YsTUFBTXBDLFdBQVcsTUFBTSxJQUFJLENBQUNULFdBQVcsQ0FBQyxvQkFBNkIsT0FBVDZDLFdBQVk7WUFDeEUsT0FBT3BDLFNBQVNOLElBQUk7UUFDdEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSw4QkFBdUYsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQ3pGO0lBQ0Y7SUFFQSxpQkFBaUI7SUFDakIsTUFBTW1DLFVBQVVDLE9BQWdCLEVBQUU7UUFDaEMsSUFBSTtZQUNGLHlEQUF5RDtZQUN6RCxNQUFNQyxXQUFXLElBQUlDO1lBQ3JCQyxPQUFPQyxPQUFPLENBQUNKLFNBQVNLLE9BQU8sQ0FBQztvQkFBQyxDQUFDQyxLQUFLQyxNQUFNO2dCQUMzQyxJQUFJQSxpQkFBaUJDLE1BQU07b0JBQ3pCUCxTQUFTUSxNQUFNLENBQUNILEtBQUtDO2dCQUN2QixPQUFPLElBQUlBLE9BQU87b0JBQ2hCTixTQUFTUSxNQUFNLENBQUNILEtBQUtDLE1BQU1HLFFBQVE7Z0JBQ3JDO1lBQ0Y7WUFFQSxNQUFNaEUsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDQyxPQUFPLEVBQUMsZ0JBQWM7Z0JBQ3pEVCxRQUFRO2dCQUNSVSxTQUFTO29CQUNQLGlCQUFpQixVQUE2QixPQUFuQixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsTUFBTTtnQkFDL0M7Z0JBQ0FDLE1BQU1pRDtZQUNSO1lBRUEsSUFBSSxDQUFDdkQsU0FBU1ksRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1iLFNBQVNjLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJQyxNQUFNLDBCQUFtRSxPQUF6Q0gsVUFBVUssT0FBTyxJQUFJbEIsU0FBU21CLFVBQVU7WUFDcEY7WUFFQSxNQUFNOEMsU0FBUyxNQUFNakUsU0FBU2MsSUFBSTtZQUNsQyxPQUFPbUQsT0FBT3ZFLElBQUk7UUFDcEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSwwQkFBbUYsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQ3JGO0lBQ0Y7SUFFQSxNQUFNZ0QsYUFBYUMsTUFBYyxFQUFFO1FBQ2pDLElBQUk7WUFDRixNQUFNbkUsV0FBVyxNQUFNLElBQUksQ0FBQ1QsV0FBVyxDQUFDLGVBQXNCLE9BQVA0RTtZQUN2RCxPQUFPbkUsU0FBU04sSUFBSTtRQUN0QixFQUFFLE9BQU8wQixPQUFPO1lBQ2QsTUFBTSxJQUFJSixNQUFNLDRCQUFxRixPQUF6REksaUJBQWlCSixRQUFRSSxNQUFNRixPQUFPLEdBQUc7UUFDdkY7SUFDRjtJQUVBLHNCQUFzQjtJQUN0QixNQUFNa0QsaUJBQWlCQyxjQUE4QixFQUFFO1FBQ3JELElBQUk7WUFDRixNQUFNckUsV0FBVyxNQUFNLElBQUksQ0FBQ1QsV0FBVyxDQUFDLFlBQVksUUFBUTtnQkFDMURpRCxRQUFRNkIsZUFBZTdCLE1BQU07Z0JBQzdCOEIsY0FBY0QsZUFBZUMsWUFBWTtnQkFDekNDLFlBQVlGLGVBQWVFLFVBQVU7Z0JBQ3JDNUIsV0FBVzBCLGVBQWUxQixTQUFTO1lBQ3JDO1lBQ0EsT0FBTzNDLFNBQVNOLElBQUk7UUFDdEIsRUFBRSxPQUFPMEIsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSxzQkFBK0UsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQ2pGO0lBQ0Y7SUFFQSxNQUFNc0QsbUJBQStDO1lBQTlCQyxlQUFBQSxpRUFBdUI7UUFDNUMsSUFBSTtZQUNGLE1BQU16RSxXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUMsZUFBNEIsT0FBYmtGO1lBQ3ZELE9BQU96RSxTQUFTTixJQUFJO1FBQ3RCLEVBQUUsT0FBTzBCLE9BQU87WUFDZCxNQUFNLElBQUlKLE1BQU0saUNBQTBGLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUM1RjtJQUNGO0lBRUEsc0JBQXNCO0lBQ3RCLE1BQU13RCxzQkFBc0J0QyxRQUFnQixFQUEwQztZQUF4Q3VDLFFBQUFBLGlFQUFnQixJQUFJQyxTQUFBQSxpRUFBaUI7UUFDakYsSUFBSTtZQUNGLE1BQU01RSxXQUFXLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQ3JDLDBCQUE0Q29GLE9BQWxCdkMsVUFBUyxXQUF5QndDLE9BQWhCRCxPQUFNLFlBQWlCLE9BQVBDO1lBRTlELE9BQU81RSxTQUFTTixJQUFJO1FBQ3RCLEVBQUUsT0FBTzBCLE9BQU87WUFDZCxNQUFNLElBQUlKLE1BQU0sc0NBQStGLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUNqRztJQUNGO0lBRUEsTUFBTTJELHNCQUFzQkMsYUFBcUIsRUFBRTtRQUNqRCxJQUFJO1lBQ0YsTUFBTTlFLFdBQVcsTUFBTSxJQUFJLENBQUNULFdBQVcsQ0FBQyxpQkFBK0IsT0FBZHVGO1lBQ3pELE9BQU85RSxTQUFTTixJQUFJO1FBQ3RCLEVBQUUsT0FBTzBCLE9BQU87WUFDZCxNQUFNLElBQUlKLE1BQU0sc0NBQStGLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUNqRztJQUNGO0lBRUEseUNBQXlDO0lBQ3pDNkQsdUJBQXVCQyxPQUFlLEVBQUVDLFNBQWlCLEVBQUVDLE1BQWMsRUFBVztRQUNsRixtRUFBbUU7UUFDbkUsMERBQTBEO1FBQzFELElBQUk7WUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxnR0FBUTtZQUMvQixNQUFNQyxvQkFBb0JGLE9BQ3ZCRyxVQUFVLENBQUMsVUFBVUosUUFDckJLLE1BQU0sQ0FBQ1AsU0FDUFEsTUFBTSxDQUFDO1lBRVYsT0FBT0wsT0FBT00sZUFBZSxDQUMzQkMsTUFBTUEsQ0FBQ0MsSUFBSSxDQUFDVixXQUFXLFFBQ3ZCUyxNQUFNQSxDQUFDQyxJQUFJLENBQUNOLG1CQUFtQjtRQUVuQyxFQUFFLE9BQU9qRSxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywwQ0FBMENBO1lBQ3hELE9BQU87UUFDVDtJQUNGO0lBRUEsZUFBZTtJQUNmLE1BQU13RSxjQUFjO1FBQ2xCLElBQUk7WUFDRixNQUFNNUYsV0FBVyxNQUFNLElBQUksQ0FBQ1QsV0FBVyxDQUFDO1lBQ3hDLE9BQU9TO1FBQ1QsRUFBRSxPQUFPb0IsT0FBTztZQUNkLE1BQU0sSUFBSUosTUFBTSx3QkFBaUYsT0FBekRJLGlCQUFpQkosUUFBUUksTUFBTUYsT0FBTyxHQUFHO1FBQ25GO0lBQ0Y7SUF2U0EsWUFBWWQsTUFBb0IsQ0FBRTtRQUNoQyxJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNGLE9BQU8sR0FBR0UsT0FBT0YsT0FBTyxJQUMxQkUsQ0FBQUEsT0FBT3lGLFdBQVcsS0FBSyxlQUNwQiwyQkFDQSwrQkFBOEI7SUFDdEM7QUFrU0Y7QUFFQSxzQ0FBc0M7QUFDdEMsSUFBSUMsd0JBQThDO0FBRTNDLFNBQVNDLG9CQUFvQjNGLE1BQXFCO0lBQ3ZELElBQUksQ0FBQzBGLHlCQUF5QjFGLFFBQVE7UUFDcEMsTUFBTUMsU0FBUzJGLDRDQUFzQyxJQUFJLENBQUU7UUFDM0QsTUFBTUcsZ0JBQWdCL0YsVUFBVTtZQUM5QkM7WUFDQXdGLGFBQWEsU0FBMkMsSUFBaUMsQ0FBUztZQUNsRzNGLFNBQVM4Riw4QkFBdUM7UUFDbEQ7UUFFQSw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDM0YsUUFBUTtZQUNYZ0IsUUFBUUksSUFBSSxDQUFDO1FBQ2Y7UUFFQXFFLHdCQUF3QixJQUFJeEcsY0FBYzZHO0lBQzVDO0lBRUEsT0FBT0w7QUFDVDtBQUVBLGlDQUFpQztBQUMxQixNQUFNUSxnQkFBZ0JQLHNCQUFzQiIsInNvdXJjZXMiOlsiL2hvbWUvZXJyb3I1MS9iaXRub2IvcHJvamVjdC92aWxsYWdlLXNhY2NvL3NyYy9zZXJ2aWNlcy9iaXRub2Iuc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJpdG5vYiBTZXJ2aWNlIC0gQmxvY2tjaGFpbiBpbnRlZ3JhdGlvbiBmb3IgU0FDQ08gcGxhdGZvcm1cbiAqIEhhbmRsZXMgQml0Y29pbiBMaWdodG5pbmcgTmV0d29yayBwYXltZW50cywgd2FsbGV0IG9wZXJhdGlvbnMsIGFuZCBLWUNcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEJpdG5vYkNvbmZpZyB7XG4gIGFwaUtleTogc3RyaW5nO1xuICBlbnZpcm9ubWVudDogJ3NhbmRib3gnIHwgJ3Byb2R1Y3Rpb24nO1xuICBiYXNlVVJMPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldERhdGEge1xuICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBmaXJzdE5hbWU6IHN0cmluZztcbiAgbGFzdE5hbWU6IHN0cmluZztcbiAgZGF0ZU9mQmlydGg/OiBzdHJpbmc7XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bWVudERhdGEge1xuICBhbW91bnQ6IG51bWJlcjtcbiAgY3VycmVuY3k6IHN0cmluZztcbiAgcmVjaXBpZW50SWQ/OiBzdHJpbmc7XG4gIHBob25lTnVtYmVyPzogc3RyaW5nO1xuICBlbWFpbD86IHN0cmluZztcbiAgcmVmZXJlbmNlOiBzdHJpbmc7XG4gIG5hcnJhdGlvbj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaWdodG5pbmdJbnZvaWNlRGF0YSB7XG4gIGFtb3VudDogbnVtYmVyO1xuICBjdXJyZW5jeTogc3RyaW5nO1xuICByZWZlcmVuY2U6IHN0cmluZztcbiAgbWVtbz86IHN0cmluZztcbiAgZXhwaXJlc0luPzogbnVtYmVyOyAvLyBzZWNvbmRzXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgS1lDRGF0YSB7XG4gIGZpcnN0TmFtZTogc3RyaW5nO1xuICBsYXN0TmFtZTogc3RyaW5nO1xuICBkYXRlT2ZCaXJ0aDogc3RyaW5nO1xuICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGlkVHlwZTogJ25pbicgfCAncGFzc3BvcnQnIHwgJ2RyaXZlcnNfbGljZW5zZSc7XG4gIGlkTnVtYmVyOiBzdHJpbmc7XG4gIGlkRG9jdW1lbnQ/OiBGaWxlO1xuICBwcm9vZk9mQWRkcmVzcz86IEZpbGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2lvbkRhdGEge1xuICBhbW91bnQ6IG51bWJlcjtcbiAgZnJvbUN1cnJlbmN5OiBzdHJpbmc7XG4gIHRvQ3VycmVuY3k6IHN0cmluZztcbiAgcmVmZXJlbmNlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBCaXRub2JTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBjb25maWc6IEJpdG5vYkNvbmZpZztcbiAgcHJpdmF0ZSBiYXNlVVJMOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBCaXRub2JDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmJhc2VVUkwgPSBjb25maWcuYmFzZVVSTCB8fCBcbiAgICAgIChjb25maWcuZW52aXJvbm1lbnQgPT09ICdwcm9kdWN0aW9uJyBcbiAgICAgICAgPyAnaHR0cHM6Ly9hcGkuYml0bm9iLmNvbScgXG4gICAgICAgIDogJ2h0dHBzOi8vc2FuZGJveGFwaS5iaXRub2IuY29tJyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG1ha2VSZXF1ZXN0KGVuZHBvaW50OiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nID0gJ0dFVCcsIGRhdGE/OiBhbnkpIHtcbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIHRpbWVvdXQgY29udHJvbGxlclxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCAxMDAwMCk7IC8vIDEwIHNlY29uZCB0aW1lb3V0XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfSR7ZW5kcG9pbnR9YCwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuY29uZmlnLmFwaUtleX1gLFxuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGRhdGEgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIH0pO1xuXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQml0bm9iIEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9IC0gJHtlcnJvckRhdGEubWVzc2FnZSB8fCByZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdCaXRub2IgU2VydmljZSBFcnJvcjonLCBlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBzcGVjaWZpYyBuZXR3b3JrIGVycm9yc1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2dldGFkZHJpbmZvIEVOT1RGT1VORCcpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2ZldGNoIGZhaWxlZCcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaXRub2Igc2VydmljZSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQml0bm9iIHNlcnZpY2UgcmVxdWVzdCB0aW1lZCBvdXQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgQml0bm9iIHNlcnZpY2UgaXMgYXZhaWxhYmxlXG4gIGFzeW5jIGlzU2VydmljZUF2YWlsYWJsZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgQVBJIGtleSBpcyBjb25maWd1cmVkXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLmFwaUtleSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0JpdG5vYiBBUEkga2V5IG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHJ5IGEgc2ltcGxlIHBpbmcvaGVhbHRoIGNoZWNrXG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCcvcGluZycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignQml0bm9iIHNlcnZpY2UgdW5hdmFpbGFibGU6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF1dGhlbnRpY2F0aW9uIGFuZCBVc2VyIE1hbmFnZW1lbnRcbiAgYXN5bmMgY3JlYXRlV2FsbGV0KHVzZXJEYXRhOiBXYWxsZXREYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHNlcnZpY2UgaXMgYXZhaWxhYmxlXG4gICAgICBjb25zdCBpc0F2YWlsYWJsZSA9IGF3YWl0IHRoaXMuaXNTZXJ2aWNlQXZhaWxhYmxlKCk7XG4gICAgICBpZiAoIWlzQXZhaWxhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQml0bm9iIHNlcnZpY2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL3dhbGxldHMvY3JlYXRlJywgJ1BPU1QnLCB7XG4gICAgICAgIHBob25lTnVtYmVyOiB1c2VyRGF0YS5waG9uZU51bWJlcixcbiAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICBmaXJzdE5hbWU6IHVzZXJEYXRhLmZpcnN0TmFtZSxcbiAgICAgICAgbGFzdE5hbWU6IHVzZXJEYXRhLmxhc3ROYW1lLFxuICAgICAgICBkYXRlT2ZCaXJ0aDogdXNlckRhdGEuZGF0ZU9mQmlydGgsXG4gICAgICAgIGFkZHJlc3M6IHVzZXJEYXRhLmFkZHJlc3MsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdCaXRub2Igd2FsbGV0IGNyZWF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgV2FsbGV0IGNyZWF0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRXYWxsZXREZXRhaWxzKHdhbGxldElkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAvd2FsbGV0cy8ke3dhbGxldElkfWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB3YWxsZXQgZGV0YWlsczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRXYWxsZXRCYWxhbmNlKHdhbGxldElkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAvd2FsbGV0cy8ke3dhbGxldElkfS9iYWxhbmNlYCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWxhbmNlIGlucXVpcnkgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIExpZ2h0bmluZyBOZXR3b3JrIE9wZXJhdGlvbnNcbiAgYXN5bmMgc2VuZExpZ2h0bmluZ1BheW1lbnQocGF5bWVudERhdGE6IFBheW1lbnREYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2xpZ2h0bmluZy9zZW5kJywgJ1BPU1QnLCB7XG4gICAgICAgIGFtb3VudDogcGF5bWVudERhdGEuYW1vdW50LFxuICAgICAgICBjdXJyZW5jeTogcGF5bWVudERhdGEuY3VycmVuY3ksXG4gICAgICAgIHJlY2lwaWVudElkOiBwYXltZW50RGF0YS5yZWNpcGllbnRJZCxcbiAgICAgICAgcGhvbmVOdW1iZXI6IHBheW1lbnREYXRhLnBob25lTnVtYmVyLFxuICAgICAgICBlbWFpbDogcGF5bWVudERhdGEuZW1haWwsXG4gICAgICAgIHJlZmVyZW5jZTogcGF5bWVudERhdGEucmVmZXJlbmNlLFxuICAgICAgICBuYXJyYXRpb246IHBheW1lbnREYXRhLm5hcnJhdGlvbiB8fCAnU0FDQ08gUGxhdGZvcm0gUGF5bWVudCcsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExpZ2h0bmluZyBwYXltZW50IGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjcmVhdGVMaWdodG5pbmdJbnZvaWNlKGludm9pY2VEYXRhOiBMaWdodG5pbmdJbnZvaWNlRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy9saWdodG5pbmcvaW52b2ljZScsICdQT1NUJywge1xuICAgICAgICBhbW91bnQ6IGludm9pY2VEYXRhLmFtb3VudCxcbiAgICAgICAgY3VycmVuY3k6IGludm9pY2VEYXRhLmN1cnJlbmN5LFxuICAgICAgICByZWZlcmVuY2U6IGludm9pY2VEYXRhLnJlZmVyZW5jZSxcbiAgICAgICAgbWVtbzogaW52b2ljZURhdGEubWVtbyB8fCAnU0FDQ08gUGxhdGZvcm0gUGF5bWVudCcsXG4gICAgICAgIGV4cGlyZXNJbjogaW52b2ljZURhdGEuZXhwaXJlc0luIHx8IDM2MDAsIC8vIDEgaG91ciBkZWZhdWx0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludm9pY2UgY3JlYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHBheUxpZ2h0bmluZ0ludm9pY2UoaW52b2ljZTogc3RyaW5nLCB3YWxsZXRJZDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2xpZ2h0bmluZy9wYXknLCAnUE9TVCcsIHtcbiAgICAgICAgaW52b2ljZSxcbiAgICAgICAgd2FsbGV0SWQsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludm9pY2UgcGF5bWVudCBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQml0Y29pbiBPbi1DaGFpbiBPcGVyYXRpb25zXG4gIGFzeW5jIHNlbmRCaXRjb2luKHBheW1lbnREYXRhOiBQYXltZW50RGF0YSAmIHsgYWRkcmVzczogc3RyaW5nIH0pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCcvYml0Y29pbi9zZW5kJywgJ1BPU1QnLCB7XG4gICAgICAgIGFtb3VudDogcGF5bWVudERhdGEuYW1vdW50LFxuICAgICAgICBhZGRyZXNzOiBwYXltZW50RGF0YS5hZGRyZXNzLFxuICAgICAgICByZWZlcmVuY2U6IHBheW1lbnREYXRhLnJlZmVyZW5jZSxcbiAgICAgICAgbmFycmF0aW9uOiBwYXltZW50RGF0YS5uYXJyYXRpb24gfHwgJ1NBQ0NPIFBsYXRmb3JtIFBheW1lbnQnLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRjb2luIHRyYW5zYWN0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZW5lcmF0ZUJpdGNvaW5BZGRyZXNzKHdhbGxldElkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAvYml0Y29pbi9hZGRyZXNzLyR7d2FsbGV0SWR9YCwgJ1BPU1QnKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZHJlc3MgZ2VuZXJhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gS1lDIE9wZXJhdGlvbnNcbiAgYXN5bmMgc3VibWl0S1lDKGt5Y0RhdGE6IEtZQ0RhdGEpIHtcbiAgICB0cnkge1xuICAgICAgLy8gTm90ZTogRmlsZSB1cGxvYWRzIHdvdWxkIG5lZWQgRm9ybURhdGEgaW5zdGVhZCBvZiBKU09OXG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoa3ljRGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9reWMvc3VibWl0YCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuY29uZmlnLmFwaUtleX1gLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLWUMgc3VibWlzc2lvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhLm1lc3NhZ2UgfHwgcmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtZQyBzdWJtaXNzaW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRLWUNTdGF0dXModXNlcklkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAva3ljL3N0YXR1cy8ke3VzZXJJZH1gKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtZQyBzdGF0dXMgY2hlY2sgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEN1cnJlbmN5IENvbnZlcnNpb25cbiAgYXN5bmMgY29udmVydEJUQ1RvRmlhdChjb252ZXJzaW9uRGF0YTogQ29udmVyc2lvbkRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCcvY29udmVydCcsICdQT1NUJywge1xuICAgICAgICBhbW91bnQ6IGNvbnZlcnNpb25EYXRhLmFtb3VudCxcbiAgICAgICAgZnJvbUN1cnJlbmN5OiBjb252ZXJzaW9uRGF0YS5mcm9tQ3VycmVuY3ksXG4gICAgICAgIHRvQ3VycmVuY3k6IGNvbnZlcnNpb25EYXRhLnRvQ3VycmVuY3ksXG4gICAgICAgIHJlZmVyZW5jZTogY29udmVyc2lvbkRhdGEucmVmZXJlbmNlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRFeGNoYW5nZVJhdGVzKGJhc2VDdXJyZW5jeTogc3RyaW5nID0gJ0JUQycpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAvcmF0ZXM/YmFzZT0ke2Jhc2VDdXJyZW5jeX1gKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZXhjaGFuZ2UgcmF0ZXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJhbnNhY3Rpb24gSGlzdG9yeVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkhpc3Rvcnkod2FsbGV0SWQ6IHN0cmluZywgbGltaXQ6IG51bWJlciA9IDUwLCBvZmZzZXQ6IG51bWJlciA9IDApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KFxuICAgICAgICBgL3RyYW5zYWN0aW9ucz93YWxsZXRJZD0ke3dhbGxldElkfSZsaW1pdD0ke2xpbWl0fSZvZmZzZXQ9JHtvZmZzZXR9YFxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24gaGlzdG9yeTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkRldGFpbHModHJhbnNhY3Rpb25JZDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgL3RyYW5zYWN0aW9ucy8ke3RyYW5zYWN0aW9uSWR9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uIGRldGFpbHM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV2ViaG9vayB2ZXJpZmljYXRpb24gKGZvciBiYWNrZW5kIHVzZSlcbiAgdmVyaWZ5V2ViaG9va1NpZ25hdHVyZShwYXlsb2FkOiBzdHJpbmcsIHNpZ25hdHVyZTogc3RyaW5nLCBzZWNyZXQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIEltcGxlbWVudGF0aW9uIHdvdWxkIGRlcGVuZCBvbiBCaXRub2IncyB3ZWJob29rIHNpZ25hdHVyZSBtZXRob2RcbiAgICAvLyBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgZm9yIHRoZSBhY3R1YWwgdmVyaWZpY2F0aW9uIGxvZ2ljXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgICAgY29uc3QgZXhwZWN0ZWRTaWduYXR1cmUgPSBjcnlwdG9cbiAgICAgICAgLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIHNlY3JldClcbiAgICAgICAgLnVwZGF0ZShwYXlsb2FkKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGNyeXB0by50aW1pbmdTYWZlRXF1YWwoXG4gICAgICAgIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgJ2hleCcpLFxuICAgICAgICBCdWZmZXIuZnJvbShleHBlY3RlZFNpZ25hdHVyZSwgJ2hleCcpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXZWJob29rIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBIZWFsdGggY2hlY2tcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2hlYWx0aCcpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhlYWx0aCBjaGVjayBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFNpbmdsZXRvbiBpbnN0YW5jZSBmb3IgZnJvbnRlbmQgdXNlXG5sZXQgYml0bm9iU2VydmljZUluc3RhbmNlOiBCaXRub2JTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCaXRub2JTZXJ2aWNlKGNvbmZpZz86IEJpdG5vYkNvbmZpZyk6IEJpdG5vYlNlcnZpY2Uge1xuICBpZiAoIWJpdG5vYlNlcnZpY2VJbnN0YW5jZSB8fCBjb25maWcpIHtcbiAgICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CSVROT0JfQVBJX0tFWSB8fCAnJztcbiAgICBjb25zdCBzZXJ2aWNlQ29uZmlnID0gY29uZmlnIHx8IHtcbiAgICAgIGFwaUtleSxcbiAgICAgIGVudmlyb25tZW50OiAocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQklUTk9CX0VOVklST05NRU5UIGFzICdzYW5kYm94JyB8ICdwcm9kdWN0aW9uJykgfHwgJ3NhbmRib3gnLFxuICAgICAgYmFzZVVSTDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQklUTk9CX0JBU0VfVVJMLFxuICAgIH07XG5cbiAgICAvLyBXYXJuIGlmIEFQSSBrZXkgaXMgbWlzc2luZ1xuICAgIGlmICghYXBpS2V5KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0JpdG5vYiBBUEkga2V5IG5vdCBjb25maWd1cmVkLiBCaXRjb2luIHdhbGxldCBmZWF0dXJlcyB3aWxsIGJlIGRpc2FibGVkLicpO1xuICAgIH1cblxuICAgIGJpdG5vYlNlcnZpY2VJbnN0YW5jZSA9IG5ldyBCaXRub2JTZXJ2aWNlKHNlcnZpY2VDb25maWcpO1xuICB9XG5cbiAgcmV0dXJuIGJpdG5vYlNlcnZpY2VJbnN0YW5jZTtcbn1cblxuLy8gRGVmYXVsdCBleHBvcnQgZm9yIGNvbnZlbmllbmNlXG5leHBvcnQgY29uc3QgYml0bm9iU2VydmljZSA9IGNyZWF0ZUJpdG5vYlNlcnZpY2UoKTtcbiJdLCJuYW1lcyI6WyJCaXRub2JTZXJ2aWNlIiwibWFrZVJlcXVlc3QiLCJlbmRwb2ludCIsIm1ldGhvZCIsImRhdGEiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsImJhc2VVUkwiLCJoZWFkZXJzIiwiY29uZmlnIiwiYXBpS2V5IiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1bmRlZmluZWQiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsIkVycm9yIiwic3RhdHVzIiwibWVzc2FnZSIsInN0YXR1c1RleHQiLCJlcnJvciIsImNvbnNvbGUiLCJpbmNsdWRlcyIsIm5hbWUiLCJpc1NlcnZpY2VBdmFpbGFibGUiLCJ3YXJuIiwiY3JlYXRlV2FsbGV0IiwidXNlckRhdGEiLCJpc0F2YWlsYWJsZSIsInBob25lTnVtYmVyIiwiZW1haWwiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImRhdGVPZkJpcnRoIiwiYWRkcmVzcyIsImdldFdhbGxldERldGFpbHMiLCJ3YWxsZXRJZCIsImdldFdhbGxldEJhbGFuY2UiLCJzZW5kTGlnaHRuaW5nUGF5bWVudCIsInBheW1lbnREYXRhIiwiYW1vdW50IiwiY3VycmVuY3kiLCJyZWNpcGllbnRJZCIsInJlZmVyZW5jZSIsIm5hcnJhdGlvbiIsImNyZWF0ZUxpZ2h0bmluZ0ludm9pY2UiLCJpbnZvaWNlRGF0YSIsIm1lbW8iLCJleHBpcmVzSW4iLCJwYXlMaWdodG5pbmdJbnZvaWNlIiwiaW52b2ljZSIsInNlbmRCaXRjb2luIiwiZ2VuZXJhdGVCaXRjb2luQWRkcmVzcyIsInN1Ym1pdEtZQyIsImt5Y0RhdGEiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsIkZpbGUiLCJhcHBlbmQiLCJ0b1N0cmluZyIsInJlc3VsdCIsImdldEtZQ1N0YXR1cyIsInVzZXJJZCIsImNvbnZlcnRCVENUb0ZpYXQiLCJjb252ZXJzaW9uRGF0YSIsImZyb21DdXJyZW5jeSIsInRvQ3VycmVuY3kiLCJnZXRFeGNoYW5nZVJhdGVzIiwiYmFzZUN1cnJlbmN5IiwiZ2V0VHJhbnNhY3Rpb25IaXN0b3J5IiwibGltaXQiLCJvZmZzZXQiLCJnZXRUcmFuc2FjdGlvbkRldGFpbHMiLCJ0cmFuc2FjdGlvbklkIiwidmVyaWZ5V2ViaG9va1NpZ25hdHVyZSIsInBheWxvYWQiLCJzaWduYXR1cmUiLCJzZWNyZXQiLCJjcnlwdG8iLCJyZXF1aXJlIiwiZXhwZWN0ZWRTaWduYXR1cmUiLCJjcmVhdGVIbWFjIiwidXBkYXRlIiwiZGlnZXN0IiwidGltaW5nU2FmZUVxdWFsIiwiQnVmZmVyIiwiZnJvbSIsImhlYWx0aENoZWNrIiwiZW52aXJvbm1lbnQiLCJiaXRub2JTZXJ2aWNlSW5zdGFuY2UiLCJjcmVhdGVCaXRub2JTZXJ2aWNlIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0JJVE5PQl9BUElfS0VZIiwic2VydmljZUNvbmZpZyIsIk5FWFRfUFVCTElDX0JJVE5PQl9FTlZJUk9OTUVOVCIsIk5FWFRfUFVCTElDX0JJVE5PQl9CQVNFX1VSTCIsImJpdG5vYlNlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/bitnob.service.ts\n"));

/***/ })

});