"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/services/bitnob.service.ts":
/*!****************************************!*\
  !*** ./src/services/bitnob.service.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BitnobService: function() { return /* binding */ BitnobService; },\n/* harmony export */   bitnobService: function() { return /* binding */ bitnobService; },\n/* harmony export */   createBitnobService: function() { return /* binding */ createBitnobService; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/**\n * Bitnob Service - Blockchain integration for SACCO platform\n * Handles Bitcoin Lightning Network payments, wallet operations, and KYC\n */ class BitnobService {\n    async makeRequest(endpoint) {\n        let method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"GET\", data = arguments.length > 2 ? arguments[2] : void 0;\n        try {\n            // Create timeout controller\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 10000); // 10 second timeout\n            const response = await fetch(\"\".concat(this.baseURL).concat(endpoint), {\n                method,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Authorization\": \"Bearer \".concat(this.config.apiKey),\n                    \"Accept\": \"application/json\"\n                },\n                body: data ? JSON.stringify(data) : undefined,\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(\"Bitnob API Error: \".concat(response.status, \" - \").concat(errorData.message || response.statusText));\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Bitnob Service Error:\", error);\n            // Handle specific network errors\n            if (error instanceof Error) {\n                if (error.message.includes(\"getaddrinfo ENOTFOUND\") || error.message.includes(\"fetch failed\")) {\n                    throw new Error(\"Bitnob service is currently unavailable. Please try again later.\");\n                }\n                if (error.name === \"AbortError\") {\n                    throw new Error(\"Bitnob service request timed out. Please try again.\");\n                }\n            }\n            throw error;\n        }\n    }\n    // Check if Bitnob service is available\n    async isServiceAvailable() {\n        try {\n            // Try a simple ping/health check\n            await this.makeRequest(\"/api/v1/ping\");\n            return true;\n        } catch (error) {\n            console.warn(\"Bitnob service unavailable:\", error);\n            return false;\n        }\n    }\n    // Authentication and User Management\n    async createWallet(userData) {\n        try {\n            // First check if service is available\n            const isAvailable = await this.isServiceAvailable();\n            if (!isAvailable) {\n                throw new Error(\"Bitnob service is currently unavailable\");\n            }\n            const response = await this.makeRequest(\"/api/v1/wallets/create\", \"POST\", {\n                phoneNumber: userData.phoneNumber,\n                email: userData.email,\n                firstName: userData.firstName,\n                lastName: userData.lastName,\n                dateOfBirth: userData.dateOfBirth,\n                address: userData.address\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Bitnob wallet creation error:\", error);\n            throw new Error(\"Wallet creation failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    async getWalletDetails(walletId) {\n        try {\n            const response = await this.makeRequest(\"/api/v1/wallets/\".concat(walletId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get wallet details: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    async getWalletBalance(walletId) {\n        try {\n            const response = await this.makeRequest(\"/api/v1/wallets/\".concat(walletId, \"/balance\"));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Balance inquiry failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    // Lightning Network Operations\n    async sendLightningPayment(paymentData) {\n        try {\n            const response = await this.makeRequest(\"/api/v1/lightning/send\", \"POST\", {\n                amount: paymentData.amount,\n                currency: paymentData.currency,\n                recipientId: paymentData.recipientId,\n                phoneNumber: paymentData.phoneNumber,\n                email: paymentData.email,\n                reference: paymentData.reference,\n                narration: paymentData.narration || \"SACCO Platform Payment\"\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Lightning payment failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    async createLightningInvoice(invoiceData) {\n        try {\n            const response = await this.makeRequest(\"/api/v1/lightning/invoice\", \"POST\", {\n                amount: invoiceData.amount,\n                currency: invoiceData.currency,\n                reference: invoiceData.reference,\n                memo: invoiceData.memo || \"SACCO Platform Payment\",\n                expiresIn: invoiceData.expiresIn || 3600\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Invoice creation failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    async payLightningInvoice(invoice, walletId) {\n        try {\n            const response = await this.makeRequest(\"/api/v1/lightning/pay\", \"POST\", {\n                invoice,\n                walletId\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Invoice payment failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    // Bitcoin On-Chain Operations\n    async sendBitcoin(paymentData) {\n        try {\n            const response = await this.makeRequest(\"/api/v1/bitcoin/send\", \"POST\", {\n                amount: paymentData.amount,\n                address: paymentData.address,\n                reference: paymentData.reference,\n                narration: paymentData.narration || \"SACCO Platform Payment\"\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Bitcoin transaction failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    async generateBitcoinAddress(walletId) {\n        try {\n            const response = await this.makeRequest(\"/api/v1/bitcoin/address/\".concat(walletId), \"POST\");\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Address generation failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    // KYC Operations\n    async submitKYC(kycData) {\n        try {\n            // Note: File uploads would need FormData instead of JSON\n            const formData = new FormData();\n            Object.entries(kycData).forEach((param)=>{\n                let [key, value] = param;\n                if (value instanceof File) {\n                    formData.append(key, value);\n                } else if (value) {\n                    formData.append(key, value.toString());\n                }\n            });\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/v1/kyc/submit\"), {\n                method: \"POST\",\n                headers: {\n                    \"Authorization\": \"Bearer \".concat(this.config.apiKey)\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(\"KYC submission failed: \".concat(errorData.message || response.statusText));\n            }\n            const result = await response.json();\n            return result.data;\n        } catch (error) {\n            throw new Error(\"KYC submission failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    async getKYCStatus(userId) {\n        try {\n            const response = await this.makeRequest(\"/api/v1/kyc/status/\".concat(userId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"KYC status check failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    // Currency Conversion\n    async convertBTCToFiat(conversionData) {\n        try {\n            const response = await this.makeRequest(\"/api/v1/convert\", \"POST\", {\n                amount: conversionData.amount,\n                fromCurrency: conversionData.fromCurrency,\n                toCurrency: conversionData.toCurrency,\n                reference: conversionData.reference\n            });\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Conversion failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    async getExchangeRates() {\n        let baseCurrency = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"BTC\";\n        try {\n            const response = await this.makeRequest(\"/api/v1/rates?base=\".concat(baseCurrency));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get exchange rates: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    // Transaction History\n    async getTransactionHistory(walletId) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50, offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        try {\n            const response = await this.makeRequest(\"/api/v1/transactions?walletId=\".concat(walletId, \"&limit=\").concat(limit, \"&offset=\").concat(offset));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get transaction history: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    async getTransactionDetails(transactionId) {\n        try {\n            const response = await this.makeRequest(\"/api/v1/transactions/\".concat(transactionId));\n            return response.data;\n        } catch (error) {\n            throw new Error(\"Failed to get transaction details: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    // Webhook verification (for backend use)\n    verifyWebhookSignature(payload, signature, secret) {\n        // Implementation would depend on Bitnob's webhook signature method\n        // This is a placeholder for the actual verification logic\n        try {\n            const crypto = __webpack_require__(/*! crypto */ \"(app-pages-browser)/./node_modules/next/dist/compiled/crypto-browserify/index.js\");\n            const expectedSignature = crypto.createHmac(\"sha256\", secret).update(payload).digest(\"hex\");\n            return crypto.timingSafeEqual(Buffer.from(signature, \"hex\"), Buffer.from(expectedSignature, \"hex\"));\n        } catch (error) {\n            console.error(\"Webhook signature verification failed:\", error);\n            return false;\n        }\n    }\n    // Health check\n    async healthCheck() {\n        try {\n            const response = await this.makeRequest(\"/api/v1/health\");\n            return response;\n        } catch (error) {\n            throw new Error(\"Health check failed: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }\n    constructor(config){\n        this.config = config;\n        this.baseURL = config.baseURL || (config.environment === \"production\" ? \"https://api.bitnob.com\" : \"https://sandboxapi.bitnob.com\");\n    }\n}\n// Singleton instance for frontend use\nlet bitnobServiceInstance = null;\nfunction createBitnobService(config) {\n    if (!bitnobServiceInstance || config) {\n        const serviceConfig = config || {\n            apiKey: \"pk.e9dc8b598acf.8a2975318e1e4f001fbb964f6\" || 0,\n            environment: \"sandbox\" || 0,\n            baseURL: \"https://sandboxapi.bitnob.com\"\n        };\n        bitnobServiceInstance = new BitnobService(serviceConfig);\n    }\n    return bitnobServiceInstance;\n}\n// Default export for convenience\nconst bitnobService = createBitnobService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9iaXRub2Iuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7OztDQUdDLEdBdURNLE1BQU1BO0lBWVgsTUFBY0MsWUFBWUMsUUFBZ0IsRUFBc0M7WUFBcENDLFNBQUFBLGlFQUFpQixPQUFPQztRQUNsRSxJQUFJO1lBQ0YsNEJBQTRCO1lBQzVCLE1BQU1DLGFBQWEsSUFBSUM7WUFDdkIsTUFBTUMsWUFBWUMsV0FBVyxJQUFNSCxXQUFXSSxLQUFLLElBQUksUUFBUSxvQkFBb0I7WUFFbkYsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQWtCVCxPQUFmLElBQUksQ0FBQ1UsT0FBTyxFQUFZLE9BQVRWLFdBQVk7Z0JBQ3pEQztnQkFDQVUsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLGlCQUFpQixVQUE2QixPQUFuQixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsTUFBTTtvQkFDN0MsVUFBVTtnQkFDWjtnQkFDQUMsTUFBTVosT0FBT2EsS0FBS0MsU0FBUyxDQUFDZCxRQUFRZTtnQkFDcENDLFFBQVFmLFdBQVdlLE1BQU07WUFDM0I7WUFFQUMsYUFBYWQ7WUFFYixJQUFJLENBQUNHLFNBQVNZLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNYixTQUFTYyxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSUMsTUFBTSxxQkFBMENILE9BQXJCYixTQUFTaUIsTUFBTSxFQUFDLE9BQThDLE9BQXpDSixVQUFVSyxPQUFPLElBQUlsQixTQUFTbUIsVUFBVTtZQUNwRztZQUVBLE9BQU8sTUFBTW5CLFNBQVNjLElBQUk7UUFDNUIsRUFBRSxPQUFPTSxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyx5QkFBeUJBO1lBRXZDLGlDQUFpQztZQUNqQyxJQUFJQSxpQkFBaUJKLE9BQU87Z0JBQzFCLElBQUlJLE1BQU1GLE9BQU8sQ0FBQ0ksUUFBUSxDQUFDLDRCQUE0QkYs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d0UsY0FBYztRQUNsQixJQUFJO1lBQ0YsTUFBTTVGLFdBQVcsTUFBTSxJQUFJLENBQUNULFdBQVcsQ0FBQztZQUN4QyxPQUFPUztRQUNULEVBQUUsT0FBT29CLE9BQU87WUFDZCxNQUFNLElBQUlKLE1BQU0sd0JBQWlGLE9BQXpESSxpQkFBaUJKLFFBQVFJLE1BQU1GLE9BQU8sR0FBRztRQUNuRjtJQUNGO0lBalNBMkUsWUFBWXpGLE1BQW9CLENBQUU7UUFDaEMsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRixPQUFPLEdBQUdFLE9BQU9GLE9BQU8sSUFDMUJFLENBQUFBLE9BQU8wRixXQUFXLEtBQUssZUFDcEIsMkJBQ0EsK0JBQThCO0lBQ3RDO0FBNFJGO0FBRUEsc0NBQXNDO0FBQ3RDLElBQUlDLHdCQUE4QztBQUUzQyxTQUFTQyxvQkFBb0I1RixNQUFxQjtJQUN2RCxJQUFJLENBQUMyRix5QkFBeUIzRixRQUFRO1FBQ3BDLE1BQU02RixnQkFBZ0I3RixVQUFVO1lBQzlCQyxRQUFRNkYsMkNBQXNDLElBQUk7WUFDbERKLGFBQWEsU0FBMkMsSUFBaUM7WUFDekY1RixTQUFTZ0csK0JBQXVDO1FBQ2xEO1FBRUFILHdCQUF3QixJQUFJekcsY0FBYzJHO0lBQzVDO0lBRUEsT0FBT0Y7QUFDVDtBQUVBLGlDQUFpQztBQUMxQixNQUFNUSxnQkFBZ0JQLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvYml0bm9iLnNlcnZpY2UudHM/ZDI5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJpdG5vYiBTZXJ2aWNlIC0gQmxvY2tjaGFpbiBpbnRlZ3JhdGlvbiBmb3IgU0FDQ08gcGxhdGZvcm1cbiAqIEhhbmRsZXMgQml0Y29pbiBMaWdodG5pbmcgTmV0d29yayBwYXltZW50cywgd2FsbGV0IG9wZXJhdGlvbnMsIGFuZCBLWUNcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEJpdG5vYkNvbmZpZyB7XG4gIGFwaUtleTogc3RyaW5nO1xuICBlbnZpcm9ubWVudDogJ3NhbmRib3gnIHwgJ3Byb2R1Y3Rpb24nO1xuICBiYXNlVVJMPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldERhdGEge1xuICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBmaXJzdE5hbWU6IHN0cmluZztcbiAgbGFzdE5hbWU6IHN0cmluZztcbiAgZGF0ZU9mQmlydGg/OiBzdHJpbmc7XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bWVudERhdGEge1xuICBhbW91bnQ6IG51bWJlcjtcbiAgY3VycmVuY3k6IHN0cmluZztcbiAgcmVjaXBpZW50SWQ/OiBzdHJpbmc7XG4gIHBob25lTnVtYmVyPzogc3RyaW5nO1xuICBlbWFpbD86IHN0cmluZztcbiAgcmVmZXJlbmNlOiBzdHJpbmc7XG4gIG5hcnJhdGlvbj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaWdodG5pbmdJbnZvaWNlRGF0YSB7XG4gIGFtb3VudDogbnVtYmVyO1xuICBjdXJyZW5jeTogc3RyaW5nO1xuICByZWZlcmVuY2U6IHN0cmluZztcbiAgbWVtbz86IHN0cmluZztcbiAgZXhwaXJlc0luPzogbnVtYmVyOyAvLyBzZWNvbmRzXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgS1lDRGF0YSB7XG4gIGZpcnN0TmFtZTogc3RyaW5nO1xuICBsYXN0TmFtZTogc3RyaW5nO1xuICBkYXRlT2ZCaXJ0aDogc3RyaW5nO1xuICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGlkVHlwZTogJ25pbicgfCAncGFzc3BvcnQnIHwgJ2RyaXZlcnNfbGljZW5zZSc7XG4gIGlkTnVtYmVyOiBzdHJpbmc7XG4gIGlkRG9jdW1lbnQ/OiBGaWxlO1xuICBwcm9vZk9mQWRkcmVzcz86IEZpbGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2lvbkRhdGEge1xuICBhbW91bnQ6IG51bWJlcjtcbiAgZnJvbUN1cnJlbmN5OiBzdHJpbmc7XG4gIHRvQ3VycmVuY3k6IHN0cmluZztcbiAgcmVmZXJlbmNlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBCaXRub2JTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBjb25maWc6IEJpdG5vYkNvbmZpZztcbiAgcHJpdmF0ZSBiYXNlVVJMOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBCaXRub2JDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmJhc2VVUkwgPSBjb25maWcuYmFzZVVSTCB8fCBcbiAgICAgIChjb25maWcuZW52aXJvbm1lbnQgPT09ICdwcm9kdWN0aW9uJyBcbiAgICAgICAgPyAnaHR0cHM6Ly9hcGkuYml0bm9iLmNvbScgXG4gICAgICAgIDogJ2h0dHBzOi8vc2FuZGJveGFwaS5iaXRub2IuY29tJyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG1ha2VSZXF1ZXN0KGVuZHBvaW50OiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nID0gJ0dFVCcsIGRhdGE/OiBhbnkpIHtcbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIHRpbWVvdXQgY29udHJvbGxlclxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCAxMDAwMCk7IC8vIDEwIHNlY29uZCB0aW1lb3V0XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfSR7ZW5kcG9pbnR9YCwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuY29uZmlnLmFwaUtleX1gLFxuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGRhdGEgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIH0pO1xuXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQml0bm9iIEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9IC0gJHtlcnJvckRhdGEubWVzc2FnZSB8fCByZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdCaXRub2IgU2VydmljZSBFcnJvcjonLCBlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBzcGVjaWZpYyBuZXR3b3JrIGVycm9yc1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2dldGFkZHJpbmZvIEVOT1RGT1VORCcpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2ZldGNoIGZhaWxlZCcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaXRub2Igc2VydmljZSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQml0bm9iIHNlcnZpY2UgcmVxdWVzdCB0aW1lZCBvdXQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgQml0bm9iIHNlcnZpY2UgaXMgYXZhaWxhYmxlXG4gIGFzeW5jIGlzU2VydmljZUF2YWlsYWJsZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IGEgc2ltcGxlIHBpbmcvaGVhbHRoIGNoZWNrXG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KCcvYXBpL3YxL3BpbmcnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0JpdG5vYiBzZXJ2aWNlIHVuYXZhaWxhYmxlOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBBdXRoZW50aWNhdGlvbiBhbmQgVXNlciBNYW5hZ2VtZW50XG4gIGFzeW5jIGNyZWF0ZVdhbGxldCh1c2VyRGF0YTogV2FsbGV0RGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiBzZXJ2aWNlIGlzIGF2YWlsYWJsZVxuICAgICAgY29uc3QgaXNBdmFpbGFibGUgPSBhd2FpdCB0aGlzLmlzU2VydmljZUF2YWlsYWJsZSgpO1xuICAgICAgaWYgKCFpc0F2YWlsYWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdG5vYiBzZXJ2aWNlIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy9hcGkvdjEvd2FsbGV0cy9jcmVhdGUnLCAnUE9TVCcsIHtcbiAgICAgICAgcGhvbmVOdW1iZXI6IHVzZXJEYXRhLnBob25lTnVtYmVyLFxuICAgICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXG4gICAgICAgIGZpcnN0TmFtZTogdXNlckRhdGEuZmlyc3ROYW1lLFxuICAgICAgICBsYXN0TmFtZTogdXNlckRhdGEubGFzdE5hbWUsXG4gICAgICAgIGRhdGVPZkJpcnRoOiB1c2VyRGF0YS5kYXRlT2ZCaXJ0aCxcbiAgICAgICAgYWRkcmVzczogdXNlckRhdGEuYWRkcmVzcyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0JpdG5vYiB3YWxsZXQgY3JlYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXYWxsZXQgY3JlYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFdhbGxldERldGFpbHMod2FsbGV0SWQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYC9hcGkvdjEvd2FsbGV0cy8ke3dhbGxldElkfWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB3YWxsZXQgZGV0YWlsczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRXYWxsZXRCYWxhbmNlKHdhbGxldElkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAvYXBpL3YxL3dhbGxldHMvJHt3YWxsZXRJZH0vYmFsYW5jZWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFsYW5jZSBpbnF1aXJ5IGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICAvLyBMaWdodG5pbmcgTmV0d29yayBPcGVyYXRpb25zXG4gIGFzeW5jIHNlbmRMaWdodG5pbmdQYXltZW50KHBheW1lbnREYXRhOiBQYXltZW50RGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy9hcGkvdjEvbGlnaHRuaW5nL3NlbmQnLCAnUE9TVCcsIHtcbiAgICAgICAgYW1vdW50OiBwYXltZW50RGF0YS5hbW91bnQsXG4gICAgICAgIGN1cnJlbmN5OiBwYXltZW50RGF0YS5jdXJyZW5jeSxcbiAgICAgICAgcmVjaXBpZW50SWQ6IHBheW1lbnREYXRhLnJlY2lwaWVudElkLFxuICAgICAgICBwaG9uZU51bWJlcjogcGF5bWVudERhdGEucGhvbmVOdW1iZXIsXG4gICAgICAgIGVtYWlsOiBwYXltZW50RGF0YS5lbWFpbCxcbiAgICAgICAgcmVmZXJlbmNlOiBwYXltZW50RGF0YS5yZWZlcmVuY2UsXG4gICAgICAgIG5hcnJhdGlvbjogcGF5bWVudERhdGEubmFycmF0aW9uIHx8ICdTQUNDTyBQbGF0Zm9ybSBQYXltZW50JyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGlnaHRuaW5nIHBheW1lbnQgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUxpZ2h0bmluZ0ludm9pY2UoaW52b2ljZURhdGE6IExpZ2h0bmluZ0ludm9pY2VEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2FwaS92MS9saWdodG5pbmcvaW52b2ljZScsICdQT1NUJywge1xuICAgICAgICBhbW91bnQ6IGludm9pY2VEYXRhLmFtb3VudCxcbiAgICAgICAgY3VycmVuY3k6IGludm9pY2VEYXRhLmN1cnJlbmN5LFxuICAgICAgICByZWZlcmVuY2U6IGludm9pY2VEYXRhLnJlZmVyZW5jZSxcbiAgICAgICAgbWVtbzogaW52b2ljZURhdGEubWVtbyB8fCAnU0FDQ08gUGxhdGZvcm0gUGF5bWVudCcsXG4gICAgICAgIGV4cGlyZXNJbjogaW52b2ljZURhdGEuZXhwaXJlc0luIHx8IDM2MDAsIC8vIDEgaG91ciBkZWZhdWx0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludm9pY2UgY3JlYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHBheUxpZ2h0bmluZ0ludm9pY2UoaW52b2ljZTogc3RyaW5nLCB3YWxsZXRJZDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2FwaS92MS9saWdodG5pbmcvcGF5JywgJ1BPU1QnLCB7XG4gICAgICAgIGludm9pY2UsXG4gICAgICAgIHdhbGxldElkLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZvaWNlIHBheW1lbnQgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJpdGNvaW4gT24tQ2hhaW4gT3BlcmF0aW9uc1xuICBhc3luYyBzZW5kQml0Y29pbihwYXltZW50RGF0YTogUGF5bWVudERhdGEgJiB7IGFkZHJlc3M6IHN0cmluZyB9KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2FwaS92MS9iaXRjb2luL3NlbmQnLCAnUE9TVCcsIHtcbiAgICAgICAgYW1vdW50OiBwYXltZW50RGF0YS5hbW91bnQsXG4gICAgICAgIGFkZHJlc3M6IHBheW1lbnREYXRhLmFkZHJlc3MsXG4gICAgICAgIHJlZmVyZW5jZTogcGF5bWVudERhdGEucmVmZXJlbmNlLFxuICAgICAgICBuYXJyYXRpb246IHBheW1lbnREYXRhLm5hcnJhdGlvbiB8fCAnU0FDQ08gUGxhdGZvcm0gUGF5bWVudCcsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdGNvaW4gdHJhbnNhY3Rpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlQml0Y29pbkFkZHJlc3Mod2FsbGV0SWQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYC9hcGkvdjEvYml0Y29pbi9hZGRyZXNzLyR7d2FsbGV0SWR9YCwgJ1BPU1QnKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZHJlc3MgZ2VuZXJhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gS1lDIE9wZXJhdGlvbnNcbiAgYXN5bmMgc3VibWl0S1lDKGt5Y0RhdGE6IEtZQ0RhdGEpIHtcbiAgICB0cnkge1xuICAgICAgLy8gTm90ZTogRmlsZSB1cGxvYWRzIHdvdWxkIG5lZWQgRm9ybURhdGEgaW5zdGVhZCBvZiBKU09OXG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoa3ljRGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdjEva3ljL3N1Ym1pdGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YCxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS1lDIHN1Ym1pc3Npb24gZmFpbGVkOiAke2Vycm9yRGF0YS5tZXNzYWdlIHx8IHJlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLWUMgc3VibWlzc2lvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0S1lDU3RhdHVzKHVzZXJJZDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgL2FwaS92MS9reWMvc3RhdHVzLyR7dXNlcklkfWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS1lDIHN0YXR1cyBjaGVjayBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3VycmVuY3kgQ29udmVyc2lvblxuICBhc3luYyBjb252ZXJ0QlRDVG9GaWF0KGNvbnZlcnNpb25EYXRhOiBDb252ZXJzaW9uRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoJy9hcGkvdjEvY29udmVydCcsICdQT1NUJywge1xuICAgICAgICBhbW91bnQ6IGNvbnZlcnNpb25EYXRhLmFtb3VudCxcbiAgICAgICAgZnJvbUN1cnJlbmN5OiBjb252ZXJzaW9uRGF0YS5mcm9tQ3VycmVuY3ksXG4gICAgICAgIHRvQ3VycmVuY3k6IGNvbnZlcnNpb25EYXRhLnRvQ3VycmVuY3ksXG4gICAgICAgIHJlZmVyZW5jZTogY29udmVyc2lvbkRhdGEucmVmZXJlbmNlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRFeGNoYW5nZVJhdGVzKGJhc2VDdXJyZW5jeTogc3RyaW5nID0gJ0JUQycpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAvYXBpL3YxL3JhdGVzP2Jhc2U9JHtiYXNlQ3VycmVuY3l9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IGV4Y2hhbmdlIHJhdGVzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyYW5zYWN0aW9uIEhpc3RvcnlcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25IaXN0b3J5KHdhbGxldElkOiBzdHJpbmcsIGxpbWl0OiBudW1iZXIgPSA1MCwgb2Zmc2V0OiBudW1iZXIgPSAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChcbiAgICAgICAgYC9hcGkvdjEvdHJhbnNhY3Rpb25zP3dhbGxldElkPSR7d2FsbGV0SWR9JmxpbWl0PSR7bGltaXR9Jm9mZnNldD0ke29mZnNldH1gXG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbiBoaXN0b3J5OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uRGV0YWlscyh0cmFuc2FjdGlvbklkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAvYXBpL3YxL3RyYW5zYWN0aW9ucy8ke3RyYW5zYWN0aW9uSWR9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uIGRldGFpbHM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV2ViaG9vayB2ZXJpZmljYXRpb24gKGZvciBiYWNrZW5kIHVzZSlcbiAgdmVyaWZ5V2ViaG9va1NpZ25hdHVyZShwYXlsb2FkOiBzdHJpbmcsIHNpZ25hdHVyZTogc3RyaW5nLCBzZWNyZXQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIEltcGxlbWVudGF0aW9uIHdvdWxkIGRlcGVuZCBvbiBCaXRub2IncyB3ZWJob29rIHNpZ25hdHVyZSBtZXRob2RcbiAgICAvLyBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgZm9yIHRoZSBhY3R1YWwgdmVyaWZpY2F0aW9uIGxvZ2ljXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgICAgY29uc3QgZXhwZWN0ZWRTaWduYXR1cmUgPSBjcnlwdG9cbiAgICAgICAgLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIHNlY3JldClcbiAgICAgICAgLnVwZGF0ZShwYXlsb2FkKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGNyeXB0by50aW1pbmdTYWZlRXF1YWwoXG4gICAgICAgIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgJ2hleCcpLFxuICAgICAgICBCdWZmZXIuZnJvbShleHBlY3RlZFNpZ25hdHVyZSwgJ2hleCcpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXZWJob29rIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBIZWFsdGggY2hlY2tcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCgnL2FwaS92MS9oZWFsdGgnKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIZWFsdGggY2hlY2sgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBTaW5nbGV0b24gaW5zdGFuY2UgZm9yIGZyb250ZW5kIHVzZVxubGV0IGJpdG5vYlNlcnZpY2VJbnN0YW5jZTogQml0bm9iU2VydmljZSB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQml0bm9iU2VydmljZShjb25maWc/OiBCaXRub2JDb25maWcpOiBCaXRub2JTZXJ2aWNlIHtcbiAgaWYgKCFiaXRub2JTZXJ2aWNlSW5zdGFuY2UgfHwgY29uZmlnKSB7XG4gICAgY29uc3Qgc2VydmljZUNvbmZpZyA9IGNvbmZpZyB8fCB7XG4gICAgICBhcGlLZXk6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JJVE5PQl9BUElfS0VZIHx8ICcnLFxuICAgICAgZW52aXJvbm1lbnQ6IChwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CSVROT0JfRU5WSVJPTk1FTlQgYXMgJ3NhbmRib3gnIHwgJ3Byb2R1Y3Rpb24nKSB8fCAnc2FuZGJveCcsXG4gICAgICBiYXNlVVJMOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CSVROT0JfQkFTRV9VUkwsXG4gICAgfTtcblxuICAgIGJpdG5vYlNlcnZpY2VJbnN0YW5jZSA9IG5ldyBCaXRub2JTZXJ2aWNlKHNlcnZpY2VDb25maWcpO1xuICB9XG5cbiAgcmV0dXJuIGJpdG5vYlNlcnZpY2VJbnN0YW5jZTtcbn1cblxuLy8gRGVmYXVsdCBleHBvcnQgZm9yIGNvbnZlbmllbmNlXG5leHBvcnQgY29uc3QgYml0bm9iU2VydmljZSA9IGNyZWF0ZUJpdG5vYlNlcnZpY2UoKTtcbiJdLCJuYW1lcyI6WyJCaXRub2JTZXJ2aWNlIiwibWFrZVJlcXVlc3QiLCJlbmRwb2ludCIsIm1ldGhvZCIsImRhdGEiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsImJhc2VVUkwiLCJoZWFkZXJzIiwiY29uZmlnIiwiYXBpS2V5IiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1bmRlZmluZWQiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsIkVycm9yIiwic3RhdHVzIiwibWVzc2FnZSIsInN0YXR1c1RleHQiLCJlcnJvciIsImNvbnNvbGUiLCJpbmNsdWRlcyIsIm5hbWUiLCJpc1NlcnZpY2VBdmFpbGFibGUiLCJ3YXJuIiwiY3JlYXRlV2FsbGV0IiwidXNlckRhdGEiLCJpc0F2YWlsYWJsZSIsInBob25lTnVtYmVyIiwiZW1haWwiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImRhdGVPZkJpcnRoIiwiYWRkcmVzcyIsImdldFdhbGxldERldGFpbHMiLCJ3YWxsZXRJZCIsImdldFdhbGxldEJhbGFuY2UiLCJzZW5kTGlnaHRuaW5nUGF5bWVudCIsInBheW1lbnREYXRhIiwiYW1vdW50IiwiY3VycmVuY3kiLCJyZWNpcGllbnRJZCIsInJlZmVyZW5jZSIsIm5hcnJhdGlvbiIsImNyZWF0ZUxpZ2h0bmluZ0ludm9pY2UiLCJpbnZvaWNlRGF0YSIsIm1lbW8iLCJleHBpcmVzSW4iLCJwYXlMaWdodG5pbmdJbnZvaWNlIiwiaW52b2ljZSIsInNlbmRCaXRjb2luIiwiZ2VuZXJhdGVCaXRjb2luQWRkcmVzcyIsInN1Ym1pdEtZQyIsImt5Y0RhdGEiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsIkZpbGUiLCJhcHBlbmQiLCJ0b1N0cmluZyIsInJlc3VsdCIsImdldEtZQ1N0YXR1cyIsInVzZXJJZCIsImNvbnZlcnRCVENUb0ZpYXQiLCJjb252ZXJzaW9uRGF0YSIsImZyb21DdXJyZW5jeSIsInRvQ3VycmVuY3kiLCJnZXRFeGNoYW5nZVJhdGVzIiwiYmFzZUN1cnJlbmN5IiwiZ2V0VHJhbnNhY3Rpb25IaXN0b3J5IiwibGltaXQiLCJvZmZzZXQiLCJnZXRUcmFuc2FjdGlvbkRldGFpbHMiLCJ0cmFuc2FjdGlvbklkIiwidmVyaWZ5V2ViaG9va1NpZ25hdHVyZSIsInBheWxvYWQiLCJzaWduYXR1cmUiLCJzZWNyZXQiLCJjcnlwdG8iLCJyZXF1aXJlIiwiZXhwZWN0ZWRTaWduYXR1cmUiLCJjcmVhdGVIbWFjIiwidXBkYXRlIiwiZGlnZXN0IiwidGltaW5nU2FmZUVxdWFsIiwiQnVmZmVyIiwiZnJvbSIsImhlYWx0aENoZWNrIiwiY29uc3RydWN0b3IiLCJlbnZpcm9ubWVudCIsImJpdG5vYlNlcnZpY2VJbnN0YW5jZSIsImNyZWF0ZUJpdG5vYlNlcnZpY2UiLCJzZXJ2aWNlQ29uZmlnIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0JJVE5PQl9BUElfS0VZIiwiTkVYVF9QVUJMSUNfQklUTk9CX0VOVklST05NRU5UIiwiTkVYVF9QVUJMSUNfQklUTk9CX0JBU0VfVVJMIiwiYml0bm9iU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/bitnob.service.ts\n"));

/***/ })

});